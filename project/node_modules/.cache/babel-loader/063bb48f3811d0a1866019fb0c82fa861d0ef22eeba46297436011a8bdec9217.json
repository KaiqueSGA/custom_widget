{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst form_data_1 = __importDefault(require(\"form-data\"));\nconst sleep_1 = __importDefault(require(\"../../common/sleep\"));\nconst TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\nconst dateParser_1 = __importDefault(require(\"../Utils/dateParser\"));\nclass Files extends TagoIOModule_1.default {\n  /**\r\n   * list of files in account\r\n   * @param queryObj Object with path, pagination and quantity\r\n   */\n  async list(queryObj) {\n    const result = await this.doRequest({\n      path: \"/files\",\n      method: \"GET\",\n      params: {\n        path: queryObj?.path || \"/\",\n        pagination_token: queryObj?.paginationToken,\n        qty: queryObj?.quantity || 300\n      }\n    });\n    result.files = result?.files.map(data => (0, dateParser_1.default)(data, [\"last_modified\"]));\n    return result;\n  }\n  /**\r\n   * Upload an array of files(Base64) to TagoIO\r\n   * The filename parameter is also full path\r\n   * @param fileList Array of files data to be uploaded\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     filename: \"/myfiles/myfile.ext\",\r\n   *     file: \"StringWithBase64\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\n  async uploadBase64(fileList) {\n    const result = await this.doRequest({\n      path: \"/files\",\n      method: \"POST\",\n      body: fileList\n    });\n    return result;\n  }\n  /**\r\n   * Move/Rename Files\r\n   * @param fileList Array move actions to be made\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     from: \"/myfiles/myOldName.ext\",\r\n   *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\n  async move(fileList) {\n    const result = await this.doRequest({\n      path: \"/files\",\n      method: \"PUT\",\n      body: fileList\n    });\n    return result;\n  }\n  /**\r\n   * Copy Files\r\n   * @param fileList Array of copy actions to be made\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     from: \"/myfiles/myOldName.ext\",\r\n   *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\n  async copy(fileList) {\n    const result = await this.doRequest({\n      path: \"/files/copy\",\n      method: \"PUT\",\n      body: fileList\n    });\n    return result;\n  }\n  /**\r\n   * Delete Folder or Files\r\n   * @param files An array of files or folders to be deleted\r\n   */\n  async delete(files) {\n    const result = await this.doRequest({\n      path: \"/files\",\n      method: \"DELETE\",\n      body: files\n    });\n    return result;\n  }\n  /**\r\n   * Check if file is private or public\r\n   * @param file Path of file\r\n   */\n  async checkPermission(file) {\n    const result = await this.doRequest({\n      path: \"/files/permission\",\n      method: \"GET\",\n      params: {\n        file\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Change visibility from files\r\n   * @param filesVisibility An Array with files and their visibility to be setted\r\n   */\n  async changePermission(filesVisibility) {\n    const result = await this.doRequest({\n      path: \"/files/permission\",\n      method: \"PUT\",\n      body: filesVisibility\n    });\n    return result;\n  }\n  async getPathFromUrl(url) {\n    const tagoURL = url.indexOf(\".tago.io/file/\");\n    if (tagoURL === -1) {\n      return Promise.reject(`${url} is not a TagoIO files url`);\n    }\n    return url.slice(tagoURL + 8, url.length);\n  }\n  /**\r\n   * Get a file url with authenticate token valid for 120 seconds\r\n   * @param url Full TagoIO File url\r\n   */\n  async getFileURLSigned(url) {\n    const path = await this.getPathFromUrl(url);\n    const result = await this.doRequest({\n      path,\n      method: \"GET\",\n      params: {\n        noRedirect: true\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Get file md5 with authenticate token for privates files\r\n   * @param url Full TagoIO File url\r\n   */\n  async getFileMD5(url) {\n    const path = await this.getPathFromUrl(url);\n    const result = await this.doRequest({\n      path,\n      method: \"GET\",\n      params: {\n        md5: true,\n        noRedirect: true\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Creates a multipart upload instance\r\n   * @param filename the path + filename for the file\r\n   * @param options the upload options for this file\r\n   */\n  async createMultipartUpload(filename, options) {\n    const {\n      dashboard,\n      widget,\n      fieldId,\n      isPublic,\n      contentType\n    } = options || {};\n    const path = dashboard && widget && fieldId ? `/data/files/${dashboard}/${widget}` : `/files`;\n    const result = await this.doRequest({\n      path,\n      method: \"POST\",\n      body: {\n        multipart_action: \"start\",\n        filename,\n        public: options?.isPublic,\n        contentType,\n        ...(fieldId && {\n          field_id: fieldId\n        })\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Uploads a single part to TagoIO\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param partNumber the sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n   * @param blob the portion of the file to be uploaded\r\n   * @param options the upload options for this file\r\n   */\n  async _uploadPart(filename, uploadID, partNumber, blob, options) {\n    const {\n      fieldId\n    } = options || {};\n    const path = options?.dashboard && options?.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;\n    const form = new form_data_1.default();\n    form.append(\"filename\", filename);\n    form.append(\"upload_id\", uploadID);\n    form.append(\"part\", String(partNumber));\n    form.append(\"file\", blob, filename);\n    form.append(\"multipart_action\", \"upload\");\n    if (fieldId) {\n      form.append(\"field_id\", fieldId);\n    }\n    let headers = {\n      \"Content-Type\": \"multipart/form-data\"\n    };\n    if (form.getHeaders) {\n      headers = form.getHeaders();\n    }\n    const result = await this.doRequest({\n      path,\n      method: \"POST\",\n      body: form,\n      maxContentLength: Infinity,\n      headers\n    });\n    return {\n      ETag: result.ETag,\n      PartNumber: partNumber\n    };\n  }\n  /**\r\n   * Adds an upload to the queue.\r\n   * It will try to upload for 'opts.maxTriesForEachChunk' and fail\r\n   * if it couldn't upload after those many tries.\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param partNumberthe sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n   * @param blob the portion of the file to be uploaded\r\n   * @param options see the uploadFile function\r\n   */\n  async _addToQueue(filename, uploadID, partNumber, blob, options) {\n    const maxTries = options?.maxTriesForEachChunk || 5;\n    const timeout = options?.timeoutForEachFailedChunk || 2000;\n    let tries = 0;\n    while (tries < maxTries) {\n      try {\n        const result = await this._uploadPart(filename, uploadID, partNumber, blob, options);\n        return result;\n      } catch (ex) {\n        if (isLimitError(ex)) {\n          throw ex.message;\n        }\n        await (0, sleep_1.default)(timeout);\n        tries += 1;\n        if (tries >= maxTries) {\n          throw new Error(`Could not upload part number ${partNumber}: ${ex.message}`);\n        }\n      }\n    }\n  }\n  /**\r\n   * Finishes a multipart upload instance\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param parts all the parts uploaded to the file\r\n   * @param options the upload options for this file\r\n   */\n  async _completeMultipartUpload(filename, uploadID, parts, options) {\n    const {\n      fieldId\n    } = options || {};\n    const path = options?.dashboard && options?.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;\n    const partsOrdered = parts.sort((a, b) => a.PartNumber - b.PartNumber);\n    const headers = {\n      \"Content-Type\": \"multipart/form-data\"\n    };\n    const result = await this.doRequest({\n      path,\n      method: \"POST\",\n      body: {\n        multipart_action: \"end\",\n        upload_id: uploadID,\n        filename,\n        parts: partsOrdered,\n        ...(fieldId && {\n          field_id: fieldId\n        })\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Uploads a single file to TagoIO.\r\n   * The upload is multipart, meaning that the file will be divided and sent in chunks, resulting in multiple requests being made.\r\n   *\r\n   * @param file the file to be uploaded\r\n   * @param filename the path + filename for the file\r\n   * @param options the upload options for this file\r\n   */\n  async uploadFile(file, filename, options) {\n    const MB = Math.pow(2, 20);\n    let cancelled = false;\n    if (options?.onCancelToken) {\n      options.onCancelToken(() => {\n        cancelled = true;\n      });\n    }\n    this.isCanceled(cancelled);\n    const uploadID = await this.createMultipartUpload(filename, options);\n    const bytesPerChunk = options?.chunkSize || 7 * MB;\n    const fileSize = file instanceof Buffer ? file.length : file.size;\n    const chunkAmount = Math.floor(fileSize / bytesPerChunk) + 1;\n    const partsPerTime = 3;\n    if (chunkAmount > 1 && bytesPerChunk < 5 * MB) {\n      throw new Error(\"Chunk sizes cannot be lower than 5mb if the upload will have multiple parts\");\n    }\n    let offsetStart = 0;\n    let offsetEnd = bytesPerChunk;\n    let partNumber = 1;\n    let error = null;\n    const parts = [];\n    const promises = [];\n    this.isCanceled(cancelled);\n    while (offsetStart < fileSize) {\n      const sliced = file.slice(offsetStart, offsetEnd);\n      while (promises.length >= partsPerTime) {\n        this.isCanceled(cancelled);\n        if (error) {\n          throw error;\n        }\n        await (0, sleep_1.default)(1000);\n      }\n      const promise = this._addToQueue(filename, uploadID, partNumber, sliced, options);\n      promises.push(promise);\n      promise.then(partData => {\n        if (promises.indexOf(promise) >= 0) {\n          promises.splice(promises.indexOf(promise), 1);\n        }\n        parts.push(partData);\n        if (options?.onProgress) {\n          const percentage = parts.length * 100 / chunkAmount;\n          const limitedPercentage = Math.min(percentage, 100).toFixed(2);\n          const roundedPercentage = Number(limitedPercentage);\n          options.onProgress(roundedPercentage);\n        }\n      });\n      promise.catch(err => {\n        error = err;\n      });\n      this.isCanceled(cancelled);\n      await (0, sleep_1.default)(500);\n      offsetStart = offsetEnd;\n      offsetEnd = offsetStart + bytesPerChunk;\n      partNumber += 1;\n    }\n    while (promises.length > 0) {\n      this.isCanceled(cancelled);\n      if (error) {\n        throw error;\n      }\n      await (0, sleep_1.default)(1000);\n    }\n    this.isCanceled(cancelled);\n    for (let i = 0; i < 3; i += 1) {\n      try {\n        return await this._completeMultipartUpload(filename, uploadID, parts, options);\n      } catch (ex) {\n        if (isLimitError(ex)) {\n          throw ex.message;\n        }\n        await (0, sleep_1.default)(1000);\n        if (i === 2) {\n          throw ex;\n        }\n      }\n    }\n  }\n  /**\r\n   * Throw a error if is cancelled\r\n   * @param cancelled\r\n   */\n  isCanceled(cancelled) {\n    if (cancelled) {\n      throw new Error(\"Cancelled request\");\n    }\n  }\n}\n/**\r\n * Check if the error returned from the API is a usage limit exceeded error.\r\n *\r\n * @param error Error to check.\r\n */\nfunction isLimitError(error) {\n  if (typeof error?.message !== \"string\") {\n    return false;\n  }\n  const message = error?.message;\n  // TODO: Use status code instead of string error message when available.\n  return message.startsWith(\"You have exceeded the maximum limit\");\n}\nexports.default = Files;","map":{"version":3,"mappings":"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","names":["Files","TagoIOModule_1","list","queryObj","result","doRequest","path","method","params","pagination_token","paginationToken","qty","quantity","files","map","data","uploadBase64","fileList","body","move","copy","delete","checkPermission","file","changePermission","filesVisibility","getPathFromUrl","url","tagoURL","indexOf","Promise","reject","slice","length","getFileURLSigned","noRedirect","getFileMD5","md5","createMultipartUpload","filename","options","dashboard","widget","fieldId","isPublic","contentType","multipart_action","public","field_id","_uploadPart","uploadID","partNumber","blob","form","form_data_1","append","String","headers","getHeaders","maxContentLength","Infinity","ETag","PartNumber","_addToQueue","maxTries","maxTriesForEachChunk","timeout","timeoutForEachFailedChunk","tries","ex","isLimitError","message","Error","_completeMultipartUpload","parts","partsOrdered","sort","a","b","upload_id","uploadFile","MB","Math","pow","cancelled","onCancelToken","isCanceled","bytesPerChunk","chunkSize","fileSize","Buffer","size","chunkAmount","floor","partsPerTime","offsetStart","offsetEnd","error","promises","sliced","promise","push","then","partData","splice","onProgress","percentage","limitedPercentage","min","toFixed","roundedPercentage","Number","catch","err","i","startsWith","exports"],"sources":["C:\\Users\\kaique\\Documents\\SGA\\widget\\project\\node_modules\\@tago-io\\sdk\\src\\modules\\Account\\Files.ts"],"sourcesContent":["import FormData from \"form-data\";\r\nimport { GenericID } from \"../../common/common.types\";\r\nimport sleep from \"../../common/sleep\";\r\nimport TagoIOModule, { GenericModuleParams } from \"../../common/TagoIOModule\";\r\nimport dateParser from \"../Utils/dateParser\";\r\nimport {\r\n  Base64File,\r\n  CopyFiles,\r\n  FileListInfo,\r\n  FileQuery,\r\n  FilesPermission,\r\n  MoveFiles,\r\n  UploadOptions,\r\n} from \"./files.types\";\r\n\r\nclass Files extends TagoIOModule<GenericModuleParams> {\r\n  /**\r\n   * list of files in account\r\n   * @param queryObj Object with path, pagination and quantity\r\n   */\r\n  public async list(queryObj?: FileQuery): Promise<FileListInfo> {\r\n    const result = await this.doRequest<FileListInfo>({\r\n      path: \"/files\",\r\n      method: \"GET\",\r\n      params: {\r\n        path: queryObj?.path || \"/\",\r\n        pagination_token: queryObj?.paginationToken,\r\n        qty: queryObj?.quantity || 300,\r\n      },\r\n    });\r\n\r\n    result.files = result?.files.map((data) => dateParser(data, [\"last_modified\"]));\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Upload an array of files(Base64) to TagoIO\r\n   * The filename parameter is also full path\r\n   * @param fileList Array of files data to be uploaded\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     filename: \"/myfiles/myfile.ext\",\r\n   *     file: \"StringWithBase64\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\r\n  public async uploadBase64(fileList: Base64File[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files\",\r\n      method: \"POST\",\r\n      body: fileList,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Move/Rename Files\r\n   * @param fileList Array move actions to be made\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     from: \"/myfiles/myOldName.ext\",\r\n   *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\r\n  public async move(fileList: MoveFiles[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files\",\r\n      method: \"PUT\",\r\n      body: fileList,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Copy Files\r\n   * @param fileList Array of copy actions to be made\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     from: \"/myfiles/myOldName.ext\",\r\n   *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\r\n  public async copy(fileList: CopyFiles[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files/copy\",\r\n      method: \"PUT\",\r\n      body: fileList,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Delete Folder or Files\r\n   * @param files An array of files or folders to be deleted\r\n   */\r\n  public async delete(files: string[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files\",\r\n      method: \"DELETE\",\r\n      body: files,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if file is private or public\r\n   * @param file Path of file\r\n   */\r\n  public async checkPermission(file: string): Promise<{ public: boolean }> {\r\n    const result = await this.doRequest<{ public: boolean }>({\r\n      path: \"/files/permission\",\r\n      method: \"GET\",\r\n      params: {\r\n        file,\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Change visibility from files\r\n   * @param filesVisibility An Array with files and their visibility to be setted\r\n   */\r\n  public async changePermission(filesVisibility: FilesPermission[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files/permission\",\r\n      method: \"PUT\",\r\n      body: filesVisibility,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  private async getPathFromUrl(url: string): Promise<string> {\r\n    const tagoURL = url.indexOf(\".tago.io/file/\");\r\n\r\n    if (tagoURL === -1) {\r\n      return Promise.reject(`${url} is not a TagoIO files url`);\r\n    }\r\n\r\n    return url.slice(tagoURL + 8, url.length);\r\n  }\r\n\r\n  /**\r\n   * Get a file url with authenticate token valid for 120 seconds\r\n   * @param url Full TagoIO File url\r\n   */\r\n  public async getFileURLSigned(url: string): Promise<string> {\r\n    const path = await this.getPathFromUrl(url);\r\n\r\n    const result = await this.doRequest<string>({\r\n      path,\r\n      method: \"GET\",\r\n      params: {\r\n        noRedirect: true,\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get file md5 with authenticate token for privates files\r\n   * @param url Full TagoIO File url\r\n   */\r\n  public async getFileMD5(url: string): Promise<string> {\r\n    const path = await this.getPathFromUrl(url);\r\n\r\n    const result = await this.doRequest<string>({\r\n      path,\r\n      method: \"GET\",\r\n      params: {\r\n        md5: true,\r\n        noRedirect: true,\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a multipart upload instance\r\n   * @param filename the path + filename for the file\r\n   * @param options the upload options for this file\r\n   */\r\n  private async createMultipartUpload(filename: string, options?: UploadOptions) {\r\n    const { dashboard, widget, fieldId, isPublic, contentType } = options || {};\r\n\r\n    const path = dashboard && widget && fieldId ? `/data/files/${dashboard}/${widget}` : `/files`;\r\n\r\n    const result = await this.doRequest<any>({\r\n      path,\r\n      method: \"POST\",\r\n      body: {\r\n        multipart_action: \"start\",\r\n        filename,\r\n        public: options?.isPublic,\r\n        contentType,\r\n        ...(fieldId && { field_id: fieldId }),\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Uploads a single part to TagoIO\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param partNumber the sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n   * @param blob the portion of the file to be uploaded\r\n   * @param options the upload options for this file\r\n   */\r\n  async _uploadPart(\r\n    filename: string,\r\n    uploadID: string,\r\n    partNumber: number,\r\n    blob: Buffer | Blob,\r\n    options?: UploadOptions\r\n  ) {\r\n    const { fieldId } = options || {};\r\n    const path =\r\n      options?.dashboard && options?.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;\r\n\r\n    const form = new FormData();\r\n    form.append(\"filename\", filename);\r\n    form.append(\"upload_id\", uploadID);\r\n    form.append(\"part\", String(partNumber));\r\n    form.append(\"file\", blob, filename);\r\n    form.append(\"multipart_action\", \"upload\");\r\n\r\n    if (fieldId) {\r\n      form.append(\"field_id\", fieldId);\r\n    }\r\n\r\n    let headers: any = { \"Content-Type\": \"multipart/form-data\" };\r\n    if (form.getHeaders) {\r\n      headers = form.getHeaders();\r\n    }\r\n\r\n    const result = await this.doRequest<{ ETag: string }>({\r\n      path,\r\n      method: \"POST\",\r\n      body: form,\r\n      maxContentLength: Infinity,\r\n      headers,\r\n    });\r\n\r\n    return {\r\n      ETag: result.ETag,\r\n      PartNumber: partNumber,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds an upload to the queue.\r\n   * It will try to upload for 'opts.maxTriesForEachChunk' and fail\r\n   * if it couldn't upload after those many tries.\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param partNumberthe sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n   * @param blob the portion of the file to be uploaded\r\n   * @param options see the uploadFile function\r\n   */\r\n  async _addToQueue(\r\n    filename: string,\r\n    uploadID: GenericID,\r\n    partNumber: number,\r\n    blob: Buffer | Blob,\r\n    options?: UploadOptions\r\n  ) {\r\n    const maxTries = options?.maxTriesForEachChunk || 5;\r\n    const timeout = options?.timeoutForEachFailedChunk || 2000;\r\n\r\n    let tries = 0;\r\n\r\n    while (tries < maxTries) {\r\n      try {\r\n        const result = await this._uploadPart(filename, uploadID, partNumber, blob, options);\r\n        return result;\r\n      } catch (ex) {\r\n        if (isLimitError(ex)) {\r\n          throw ex.message;\r\n        }\r\n\r\n        await sleep(timeout);\r\n\r\n        tries += 1;\r\n        if (tries >= maxTries) {\r\n          throw new Error(`Could not upload part number ${partNumber}: ${ex.message}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finishes a multipart upload instance\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param parts all the parts uploaded to the file\r\n   * @param options the upload options for this file\r\n   */\r\n  async _completeMultipartUpload(\r\n    filename: string,\r\n    uploadID: string,\r\n    parts: { ETag: String; PartNumber: number }[],\r\n    options?: UploadOptions\r\n  ) {\r\n    const { fieldId } = options || {};\r\n    const path =\r\n      options?.dashboard && options?.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;\r\n\r\n    const partsOrdered = parts.sort((a, b) => a.PartNumber - b.PartNumber);\r\n\r\n    const headers = { \"Content-Type\": \"multipart/form-data\" };\r\n\r\n    const result = await this.doRequest<{ file: string }>({\r\n      path,\r\n      method: \"POST\",\r\n      body: {\r\n        multipart_action: \"end\",\r\n        upload_id: uploadID,\r\n        filename,\r\n        parts: partsOrdered,\r\n        ...(fieldId && { field_id: fieldId }),\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Uploads a single file to TagoIO.\r\n   * The upload is multipart, meaning that the file will be divided and sent in chunks, resulting in multiple requests being made.\r\n   *\r\n   * @param file the file to be uploaded\r\n   * @param filename the path + filename for the file\r\n   * @param options the upload options for this file\r\n   */\r\n  public async uploadFile(file: Buffer | Blob, filename: string, options?: UploadOptions) {\r\n    const MB = Math.pow(2, 20);\r\n\r\n    let cancelled = false;\r\n    if (options?.onCancelToken) {\r\n      options.onCancelToken(() => {\r\n        cancelled = true;\r\n      });\r\n    }\r\n\r\n    this.isCanceled(cancelled);\r\n\r\n    const uploadID = await this.createMultipartUpload(filename, options);\r\n\r\n    const bytesPerChunk = options?.chunkSize || 7 * MB;\r\n    const fileSize = file instanceof Buffer ? file.length : file.size;\r\n    const chunkAmount = Math.floor(fileSize / bytesPerChunk) + 1;\r\n    const partsPerTime = 3;\r\n\r\n    if (chunkAmount > 1 && bytesPerChunk < 5 * MB) {\r\n      throw new Error(\"Chunk sizes cannot be lower than 5mb if the upload will have multiple parts\");\r\n    }\r\n\r\n    let offsetStart = 0;\r\n    let offsetEnd = bytesPerChunk;\r\n    let partNumber = 1;\r\n    let error = null;\r\n    const parts: any[] = [];\r\n    const promises: any[] = [];\r\n\r\n    this.isCanceled(cancelled);\r\n\r\n    while (offsetStart < fileSize) {\r\n      const sliced = file.slice(offsetStart, offsetEnd);\r\n\r\n      while (promises.length >= partsPerTime) {\r\n        this.isCanceled(cancelled);\r\n\r\n        if (error) {\r\n          throw error;\r\n        }\r\n\r\n        await sleep(1000);\r\n      }\r\n\r\n      const promise = this._addToQueue(filename, uploadID, partNumber, sliced, options);\r\n      promises.push(promise);\r\n\r\n      promise.then((partData: any) => {\r\n        if (promises.indexOf(promise) >= 0) {\r\n          promises.splice(promises.indexOf(promise), 1);\r\n        }\r\n\r\n        parts.push(partData);\r\n\r\n        if (options?.onProgress) {\r\n          const percentage = (parts.length * 100) / chunkAmount;\r\n          const limitedPercentage = Math.min(percentage, 100).toFixed(2);\r\n          const roundedPercentage = Number(limitedPercentage);\r\n          options.onProgress(roundedPercentage);\r\n        }\r\n      });\r\n\r\n      promise.catch((err: Error) => {\r\n        error = err;\r\n      });\r\n\r\n      this.isCanceled(cancelled);\r\n\r\n      await sleep(500);\r\n\r\n      offsetStart = offsetEnd;\r\n      offsetEnd = offsetStart + bytesPerChunk;\r\n      partNumber += 1;\r\n    }\r\n\r\n    while (promises.length > 0) {\r\n      this.isCanceled(cancelled);\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n      await sleep(1000);\r\n    }\r\n\r\n    this.isCanceled(cancelled);\r\n\r\n    for (let i = 0; i < 3; i += 1) {\r\n      try {\r\n        return await this._completeMultipartUpload(filename, uploadID, parts, options);\r\n      } catch (ex) {\r\n        if (isLimitError(ex)) {\r\n          throw ex.message;\r\n        }\r\n\r\n        await sleep(1000);\r\n        if (i === 2) {\r\n          throw ex;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Throw a error if is cancelled\r\n   * @param cancelled\r\n   */\r\n  private isCanceled(cancelled: boolean) {\r\n    if (cancelled) {\r\n      throw new Error(\"Cancelled request\");\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check if the error returned from the API is a usage limit exceeded error.\r\n *\r\n * @param error Error to check.\r\n */\r\nfunction isLimitError(error: any): boolean {\r\n  if (typeof error?.message !== \"string\") {\r\n    return false;\r\n  }\r\n\r\n  const message: string = error?.message;\r\n\r\n  // TODO: Use status code instead of string error message when available.\r\n  return message.startsWith(\"You have exceeded the maximum limit\");\r\n}\r\n\r\nexport default Files;\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}