{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst lodash_1 = require(\"lodash\");\nconst sleep_1 = __importDefault(require(\"../../common/sleep\"));\nconst TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\nconst dateParser_1 = __importDefault(require(\"../Utils/dateParser\"));\nclass Device extends TagoIOModule_1.default {\n  /**\r\n   * Get information about the current device\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.info();\r\n   * ```\r\n   */\n  async info() {\n    let result = await this.doRequest({\n      path: \"/info\",\n      method: \"GET\"\n    });\n    result = (0, dateParser_1.default)(result, [\"created_at\", \"updated_at\", \"last_input\", \"last_output\"]);\n    return result;\n  }\n  /**\r\n   * Send data to device\r\n   * @param data An array or one object with data to be send to TagoIO using device token\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.sendData({\r\n   *   variable: \"temperature\",\r\n   *   unit: \"F\",\r\n   *   value: 55,\r\n   *   time: \"2015-11-03 13:44:33\",\r\n   *   location: { lat: 42.2974279, lng: -85.628292 },\r\n   * });\r\n   * ```\r\n   */\n  async sendData(data) {\n    data = Array.isArray(data) ? data : [data];\n    const result = await this.doRequest({\n      path: \"/data\",\n      method: \"POST\",\n      body: data\n    });\n    return result;\n  }\n  /**\r\n   * Get data from TagoIO Device.\r\n   * @param queryParams Object with query params\r\n   * @returns An array of TagoIO registers\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.getData({\r\n   *   query: \"last_item\",\r\n   *   variable: \"humidity\",\r\n   * });\r\n   * ```\r\n   */\n  async getData(queryParams) {\n    if (queryParams?.query === \"default\") {\n      delete queryParams.query;\n    }\n    let result = await this.doRequest({\n      path: \"/data\",\n      method: \"GET\",\n      params: queryParams\n    });\n    if (typeof result === \"number\") {\n      result = [{\n        id: \"none\",\n        origin: \"?\",\n        time: new Date(),\n        value: result,\n        variable: \"?\"\n      }];\n    }\n    return result.map(item => (0, dateParser_1.default)(item, [\"time\", \"created_at\"]));\n  }\n  /**\r\n   * Edit data in a Mutable-type device.\r\n   *\r\n   * @param data Array or object with the data to be edited, each object with the data's ID.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.editData({\r\n   *   id: \"id_of_the_data_item\",\r\n   *   value: 123,\r\n   *   time: \"2022-04-01 12:34:56\",\r\n   *   location: { lat: 42.2974279, lng: -85.628292 },\r\n   * });\r\n   * ```\r\n   *\r\n   * @returns Success message with the amount of data items updated.\r\n   */\n  async editData(data) {\n    data = Array.isArray(data) ? data : [data];\n    const result = await this.doRequest({\n      path: \"/data\",\n      method: \"PUT\",\n      body: data\n    });\n    return result;\n  }\n  /**\r\n   * Delete data from device\r\n   * @param queryParams\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.deleteData({\r\n   *   query: \"last_item\",\r\n   *   variable: \"humidity\",\r\n   *   value: 10\r\n   * });\r\n   * ```\r\n   */\n  async deleteData(queryParams) {\n    if (!queryParams) {\n      queryParams = {\n        query: \"last_item\"\n      };\n    }\n    if (queryParams?.query === \"default\") {\n      delete queryParams.query;\n    }\n    const result = await this.doRequest({\n      path: \"/data\",\n      method: \"DELETE\",\n      params: queryParams\n    });\n    return result;\n  }\n  /**\r\n   * Get parameters from device\r\n   * @param onlyUnRead set true to get only unread parameters\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.getParameters();\r\n   * ```\r\n   */\n  async getParameters(status) {\n    const params = {};\n    if (status === \"onlyRead\") {\n      params.sent_status = true;\n    } else if (status === \"onlyUnRead\") {\n      params.sent_status = false;\n    }\n    // ? Support for old call (onlyUnRead?: boolean)\n    // @ts-expect-error\n    if (status === true) {\n      params.sent_status = false;\n    }\n    const result = await this.doRequest({\n      path: \"/device/params\",\n      method: \"GET\",\n      params: params\n    });\n    return result;\n  }\n  /**\r\n   * Mark parameter as read\r\n   * @param parameterID Parameter identification\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.setParameterAsRead(\"parameter_id\");\r\n   * ```\r\n   *\r\n   */\n  async setParameterAsRead(parameterID) {\n    const result = await this.doRequest({\n      path: `/device/params/${parameterID}`,\n      method: \"PUT\",\n      body: {\n        sent: true\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Get Data Streaming\r\n   *\r\n   * @experimental\r\n   * @param params Data Query\r\n   * @param options Stream options\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * for await (const items of myDevice.getDataStreaming()) {\r\n   *  console.log(items);\r\n   * }\r\n   * ```\r\n   */\n  async *getDataStreaming(params, options) {\n    const poolingRecordQty = options?.poolingRecordQty || 1000;\n    const poolingTime = options?.poolingTime || 1000; // 1 seg\n    const neverStop = options?.neverStop || false;\n    if (poolingRecordQty > 10000) {\n      throw new Error(\"The maximum of poolingRecordQty is 10000\");\n    }\n    const qty = Math.ceil(poolingRecordQty);\n    let skip = 0;\n    let stop = false;\n    while (!stop) {\n      await (0, sleep_1.default)(poolingTime);\n      yield (async () => {\n        const data = await this.getData({\n          ...params,\n          qty,\n          skip,\n          query: \"default\",\n          ordination: \"ascending\"\n        });\n        skip += data.length;\n        if (!neverStop) {\n          stop = data.length === 0 || data.length < poolingRecordQty;\n        }\n        return data;\n      })();\n    }\n  }\n  /**\r\n   * Stream data to device\r\n   *\r\n   * @experimental\r\n   * @param data An array or one object with data to be send to TagoIO using device token\r\n   * @param options Stream options\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const data = [\r\n   *     {\r\n   *       variable: \"temperature\",\r\n   *       unit: \"F\",\r\n   *       value: 55,\r\n   *       time: \"2015-11-03 13:44:33\",\r\n   *       location: { lat: 42.2974279, lng: -85.628292 },\r\n   *     },\r\n   *     {\r\n   *       variable: \"temperature\",\r\n   *       unit: \"F\",\r\n   *       value: 53,\r\n   *       time: \"2015-11-03 13:44:33\",\r\n   *       location: { lat: 43.2974279, lng: -86.628292 },\r\n   *     },\r\n   *     // ...\r\n   *   ];\r\n   *\r\n   *   const result = await myDevice.sendDataStreaming(data, {\r\n   *     poolingRecordQty: 1000,\r\n   *     poolingTime: 1000,\r\n   *   });\r\n   * ```\r\n   */\n  async sendDataStreaming(data, options) {\n    const poolingRecordQty = options?.poolingRecordQty || 1000;\n    const poolingTime = options?.poolingTime || 1000; // 1 seg\n    if (!Array.isArray(data)) {\n      return Promise.reject(\"Only data array is allowed\");\n    }\n    const dataChunk = (0, lodash_1.chunk)(data, poolingRecordQty);\n    for (const items of dataChunk) {\n      await this.sendData(items);\n      await (0, sleep_1.default)(poolingTime);\n    }\n    return `${data.length} Data added.`;\n  }\n}\nexports.default = Device;","map":{"version":3,"mappings":"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","names":["Device","TagoIOModule_1","info","result","doRequest","path","method","sendData","data","Array","isArray","body","getData","queryParams","query","params","id","origin","time","Date","value","variable","map","item","editData","deleteData","getParameters","status","sent_status","setParameterAsRead","parameterID","sent","getDataStreaming","options","poolingRecordQty","poolingTime","neverStop","Error","qty","Math","ceil","skip","stop","ordination","length","sendDataStreaming","Promise","reject","dataChunk","items","exports"],"sources":["C:\\Users\\kaique\\Documents\\SGA\\widget\\project\\node_modules\\@tago-io\\sdk\\src\\modules\\Device\\Device.ts"],"sourcesContent":["import { chunk } from \"lodash\";\r\nimport { Data, DataCreate, DataEdit, GenericID } from \"../../common/common.types\";\r\nimport sleep from \"../../common/sleep\";\r\nimport TagoIOModule from \"../../common/TagoIOModule\";\r\nimport { ConfigurationParams } from \"../Account/devices.types\";\r\nimport dateParser from \"../Utils/dateParser\";\r\nimport { DataQuery, DataQueryStreaming, DeviceConstructorParams, DeviceInfo, OptionsStreaming } from \"./device.types\";\r\n\r\nclass Device extends TagoIOModule<DeviceConstructorParams> {\r\n  /**\r\n   * Get information about the current device\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.info();\r\n   * ```\r\n   */\r\n  public async info(): Promise<DeviceInfo> {\r\n    let result = await this.doRequest<DeviceInfo>({\r\n      path: \"/info\",\r\n      method: \"GET\",\r\n    });\r\n\r\n    result = dateParser(result, [\"created_at\", \"updated_at\", \"last_input\", \"last_output\"]);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Send data to device\r\n   * @param data An array or one object with data to be send to TagoIO using device token\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.sendData({\r\n   *   variable: \"temperature\",\r\n   *   unit: \"F\",\r\n   *   value: 55,\r\n   *   time: \"2015-11-03 13:44:33\",\r\n   *   location: { lat: 42.2974279, lng: -85.628292 },\r\n   * });\r\n   * ```\r\n   */\r\n  public async sendData(data: DataCreate | DataCreate[]): Promise<string> {\r\n    data = Array.isArray(data) ? data : [data];\r\n\r\n    const result = await this.doRequest<string>({\r\n      path: \"/data\",\r\n      method: \"POST\",\r\n      body: data,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get data from TagoIO Device.\r\n   * @param queryParams Object with query params\r\n   * @returns An array of TagoIO registers\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.getData({\r\n   *   query: \"last_item\",\r\n   *   variable: \"humidity\",\r\n   * });\r\n   * ```\r\n   */\r\n  public async getData(queryParams?: DataQuery): Promise<Data[]> {\r\n    if (queryParams?.query === \"default\") {\r\n      delete queryParams.query;\r\n    }\r\n\r\n    let result = await this.doRequest<Data[] | number>({\r\n      path: \"/data\",\r\n      method: \"GET\",\r\n      params: queryParams,\r\n    });\r\n\r\n    if (typeof result === \"number\") {\r\n      result = [\r\n        {\r\n          id: \"none\",\r\n          origin: \"?\",\r\n          time: new Date(),\r\n          value: result,\r\n          variable: \"?\",\r\n        },\r\n      ] as Data[];\r\n    }\r\n\r\n    return result.map((item) => dateParser(item, [\"time\", \"created_at\"]));\r\n  }\r\n\r\n  /**\r\n   * Edit data in a Mutable-type device.\r\n   *\r\n   * @param data Array or object with the data to be edited, each object with the data's ID.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.editData({\r\n   *   id: \"id_of_the_data_item\",\r\n   *   value: 123,\r\n   *   time: \"2022-04-01 12:34:56\",\r\n   *   location: { lat: 42.2974279, lng: -85.628292 },\r\n   * });\r\n   * ```\r\n   *\r\n   * @returns Success message with the amount of data items updated.\r\n   */\r\n  public async editData(data: DataEdit | DataEdit[]): Promise<string> {\r\n    data = Array.isArray(data) ? data : [data];\r\n\r\n    const result = await this.doRequest<string>({\r\n      path: \"/data\",\r\n      method: \"PUT\",\r\n      body: data,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Delete data from device\r\n   * @param queryParams\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.deleteData({\r\n   *   query: \"last_item\",\r\n   *   variable: \"humidity\",\r\n   *   value: 10\r\n   * });\r\n   * ```\r\n   */\r\n  public async deleteData(queryParams?: DataQuery): Promise<string> {\r\n    if (!queryParams) {\r\n      queryParams = { query: \"last_item\" };\r\n    }\r\n\r\n    if (queryParams?.query === \"default\") {\r\n      delete queryParams.query;\r\n    }\r\n\r\n    const result = await this.doRequest<string>({\r\n      path: \"/data\",\r\n      method: \"DELETE\",\r\n      params: queryParams,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get parameters from device\r\n   * @param onlyUnRead set true to get only unread parameters\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.getParameters();\r\n   * ```\r\n   */\r\n  public async getParameters(status: \"all\" | \"onlyUnRead\" | \"onlyRead\"): Promise<ConfigurationParams[]> {\r\n    const params: { sent_status?: boolean } = {};\r\n\r\n    if (status === \"onlyRead\") {\r\n      params.sent_status = true;\r\n    } else if (status === \"onlyUnRead\") {\r\n      params.sent_status = false;\r\n    }\r\n\r\n    // ? Support for old call (onlyUnRead?: boolean)\r\n    // @ts-expect-error\r\n    if (status === true) {\r\n      params.sent_status = false;\r\n    }\r\n\r\n    const result = await this.doRequest<ConfigurationParams[]>({\r\n      path: \"/device/params\",\r\n      method: \"GET\",\r\n      params: params,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Mark parameter as read\r\n   * @param parameterID Parameter identification\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const result = await myDevice.setParameterAsRead(\"parameter_id\");\r\n   * ```\r\n   *\r\n   */\r\n  public async setParameterAsRead(parameterID: GenericID): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/device/params/${parameterID}`,\r\n      method: \"PUT\",\r\n      body: { sent: true },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get Data Streaming\r\n   *\r\n   * @experimental\r\n   * @param params Data Query\r\n   * @param options Stream options\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * for await (const items of myDevice.getDataStreaming()) {\r\n   *  console.log(items);\r\n   * }\r\n   * ```\r\n   */\r\n  public async *getDataStreaming(params?: DataQueryStreaming, options?: OptionsStreaming) {\r\n    const poolingRecordQty = options?.poolingRecordQty || 1000;\r\n    const poolingTime = options?.poolingTime || 1000; // 1 seg\r\n    const neverStop = options?.neverStop || false;\r\n\r\n    if (poolingRecordQty > 10000) {\r\n      throw new Error(\"The maximum of poolingRecordQty is 10000\");\r\n    }\r\n\r\n    const qty: number = Math.ceil(poolingRecordQty);\r\n    let skip: number = 0;\r\n    let stop: boolean = false;\r\n\r\n    while (!stop) {\r\n      await sleep(poolingTime);\r\n\r\n      yield (async () => {\r\n        const data = await this.getData({ ...params, qty, skip, query: \"default\", ordination: \"ascending\" });\r\n        skip += data.length;\r\n\r\n        if (!neverStop) {\r\n          stop = data.length === 0 || data.length < poolingRecordQty;\r\n        }\r\n\r\n        return data;\r\n      })();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stream data to device\r\n   *\r\n   * @experimental\r\n   * @param data An array or one object with data to be send to TagoIO using device token\r\n   * @param options Stream options\r\n   * @example\r\n   * ```js\r\n   * const myDevice = new Device({ token: \"my_device_token\" });\r\n   *\r\n   * const data = [\r\n   *     {\r\n   *       variable: \"temperature\",\r\n   *       unit: \"F\",\r\n   *       value: 55,\r\n   *       time: \"2015-11-03 13:44:33\",\r\n   *       location: { lat: 42.2974279, lng: -85.628292 },\r\n   *     },\r\n   *     {\r\n   *       variable: \"temperature\",\r\n   *       unit: \"F\",\r\n   *       value: 53,\r\n   *       time: \"2015-11-03 13:44:33\",\r\n   *       location: { lat: 43.2974279, lng: -86.628292 },\r\n   *     },\r\n   *     // ...\r\n   *   ];\r\n   *\r\n   *   const result = await myDevice.sendDataStreaming(data, {\r\n   *     poolingRecordQty: 1000,\r\n   *     poolingTime: 1000,\r\n   *   });\r\n   * ```\r\n   */\r\n  public async sendDataStreaming(data: DataCreate[], options: Omit<OptionsStreaming, \"neverStop\">) {\r\n    const poolingRecordQty = options?.poolingRecordQty || 1000;\r\n    const poolingTime = options?.poolingTime || 1000; // 1 seg\r\n\r\n    if (!Array.isArray(data)) {\r\n      return Promise.reject(\"Only data array is allowed\");\r\n    }\r\n\r\n    const dataChunk = chunk(data, poolingRecordQty);\r\n    for (const items of dataChunk) {\r\n      await this.sendData(items);\r\n\r\n      await sleep(poolingTime);\r\n    }\r\n\r\n    return `${data.length} Data added.`;\r\n  }\r\n}\r\n\r\nexport default Device;\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}