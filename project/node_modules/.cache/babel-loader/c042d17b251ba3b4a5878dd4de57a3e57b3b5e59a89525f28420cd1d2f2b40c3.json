{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst Papa = __importStar(require(\"papaparse\"));\nconst TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\n// Regular expressions that are used for parsing the strings:\n// - SPLIT is used to split the string into normal words/phrases and expressions\n// - MATCH is used to extract the parts that compose an expression\nconst RE_SPLIT_EXPRESSION = /(#[A-Z0-9]+\\.[A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*#)/;\nconst RE_MATCH_EXPRESSION = /#([A-Z0-9]+)\\.([A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*)#/;\nclass Dictionary extends TagoIOModule_1.default {\n  constructor(params) {\n    super({\n      token: params?.token || \"unknown\",\n      region: params?.region\n    });\n    this.language = params?.language || \"en-US\";\n    this.runURL = params?.runURL;\n  }\n  /**\r\n   * Get the language data for a dictionary.\r\n   *\r\n   * @param language Language.\r\n   * @param dictionary ID or Slug.\r\n   * @param runURL URL for the Run to make anonymous request.\r\n   */\n  async getLanguagesData(dictionary) {\n    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.language;\n    if (!language || !dictionary) {\n      throw new Error(\"Missing parameters\");\n    }\n    try {\n      if (!this.runURL) {\n        const response = await this.doRequest({\n          path: `/dictionary/${dictionary}/${language}`,\n          method: \"GET\",\n          cacheTTL: 3600000,\n          params: {\n            fallback: true\n          }\n        });\n        return response;\n      } else {\n        const response = await TagoIOModule_1.default.doRequestAnonymous({\n          path: `/dictionary/${this.runURL}/${dictionary}/${language}`,\n          method: \"GET\",\n          cacheTTL: 3600000\n        });\n        return response;\n      }\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\r\n   * Get value from a key in a specific dictionary for a language.\r\n   *\r\n   * @param language Name of the language (locale code).\r\n   * @param dictionary Name of the dictionary.\r\n   * @param key Name of the key.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.getValueFromKey(\"en-US\", \"TEST\", \"OK_BUTTON_LABEL\");\r\n   * ```\r\n   */\n  async getValueFromKey(language, dictionary, key) {\n    if (!language || !dictionary || !key) {\n      throw new Error(\"Missing parameters\");\n    }\n    // Get the dictionary language data from the profile route or anonymous route (Run)\n    const languagesData = await this.getLanguagesData(dictionary, language);\n    // Return expression as is if the request fails or either dictionary/key do not exist\n    if (!languagesData || !languagesData[key]) {\n      return `#${dictionary}.${key}#`;\n    }\n    return languagesData[key];\n  }\n  /**\r\n   * Parse an expression and extract the names of the dictionary, the key, and\r\n   * any arguments that are passed in the expression.\r\n   *\r\n   * Returns `null` if the value passed is not parseable by the RegEx.\r\n   *\r\n   * @param expression String expression.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.parseExpression(\"#TAGORUN.WELCOME_TEXT,Hello\");\r\n   * ```\r\n   */\n  parseExpression(expression) {\n    const splitExpression = expression.match(RE_MATCH_EXPRESSION);\n    if (!splitExpression) {\n      return null;\n    }\n    const dictionary = splitExpression[1];\n    const keyWithParams = splitExpression[2];\n    if (expression.includes(\",\")) {\n      const {\n        data\n      } = Papa.parse(keyWithParams);\n      const [key, ...params] = data[0];\n      return {\n        dictionary,\n        key,\n        params\n      };\n    }\n    return {\n      dictionary,\n      key: keyWithParams\n    };\n  }\n  /**\r\n   * Resolve an expression in a language, replacing the parameters in the\r\n   * dictionary value with the arguments passed in the expression.\r\n   *\r\n   * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.resolveExpression({\r\n   *   language: \"en-US\",\r\n   *   expression: {\r\n   *     dictionary: \"TEST\",\r\n   *     key: \"SOME_KEY\",\r\n   *     params: [\r\n   *       \"first parameter\",\r\n   *     ],\r\n   *   },\r\n   * });\r\n   * ```\r\n   */\n  async resolveExpression(resolveParams) {\n    const {\n      language,\n      expression\n    } = resolveParams;\n    const {\n      dictionary,\n      key,\n      params\n    } = expression;\n    let resolvedString;\n    // Get the dictionary value string for the expression to substitute the arguments into it\n    resolvedString = await this.getValueFromKey(language, dictionary, key);\n    params.forEach((substitution, index) => {\n      const subRegexp = new RegExp(`\\\\$${index}`, \"g\");\n      resolvedString = resolvedString.replace(subRegexp, substitution);\n    });\n    return resolvedString;\n  }\n  /**\r\n   * Get all (and only) the expressions in a string and their parameters if applicable,\r\n   * ignoring normal words and phrases.\r\n   *\r\n   * @param rawString String with words and/or expressions.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const expressions = dictionary.getExpressionsFromString(\"Words are ignored #TEST.DICT_KEY#\");\r\n   * ```\r\n   */\n  async getExpressionsFromString(rawString) {\n    const tokens = rawString.split(RE_SPLIT_EXPRESSION);\n    const expressions = tokens.filter(token => RE_SPLIT_EXPRESSION.test(token)).map(expression => this.parseExpression(expression));\n    return expressions;\n  }\n  /**\r\n   * Apply the dictionary over a string, parsing the expressions in the string and\r\n   * replacing them with the values found for the respective keys inside the dictionary\r\n   * for a language.\r\n   *\r\n   * Always returns a string. Return the translated string if there are dictionary expressions,\r\n   * the raw string with no changes if there are no expressions, and an empty string if `rawString`\r\n   * is undefined.\r\n   *\r\n   * @param rawString String with words and/or expressions.\r\n   * @param options Object containing options for the dictionary, including the language.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const result = dictionary.applyToString(\"Words are ignored #TEST.DICT_KEY#\");\r\n   * ```\r\n   */\n  async applyToString(rawString, options) {\n    const {\n      language\n    } = this;\n    // Handling undefined strings is not this function's job\n    if (!rawString || !language) {\n      return rawString || \"\";\n    }\n    // Bail early if there are no variables in the string or if the value passed\n    // is not a string, which can happen when not using TypeScript or passing the\n    // instance to a function without the type\n    if (typeof rawString !== \"string\" || !rawString.includes(\"#\")) {\n      return rawString;\n    }\n    const tokenized = rawString.split(RE_SPLIT_EXPRESSION);\n    const substitutedPromises = tokenized.map(token => {\n      const isExpression = token.startsWith(\"#\") && token.endsWith(\"#\");\n      if (isExpression) {\n        const expression = this.parseExpression(token);\n        if (!expression) {\n          return token;\n        }\n        const {\n          dictionary,\n          key,\n          params\n        } = expression;\n        return params ? this.resolveExpression({\n          language,\n          expression\n        }) : this.getValueFromKey(language, dictionary, key);\n      } else {\n        return token;\n      }\n    });\n    let resultString;\n    await Promise.all(substitutedPromises).then(resolvedValues => {\n      resultString = resolvedValues.join(\"\");\n    });\n    return resultString;\n  }\n}\nexports.default = Dictionary;","map":{"version":3,"mappings":"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","names":["RE_SPLIT_EXPRESSION","RE_MATCH_EXPRESSION","Dictionary","TagoIOModule_1","constructor","params","token","region","language","runURL","getLanguagesData","dictionary","Error","response","doRequest","path","method","cacheTTL","fallback","doRequestAnonymous","e","getValueFromKey","key","languagesData","parseExpression","expression","splitExpression","match","keyWithParams","includes","data","Papa","parse","resolveExpression","resolveParams","resolvedString","forEach","substitution","index","subRegexp","RegExp","replace","getExpressionsFromString","rawString","tokens","split","expressions","filter","test","map","applyToString","options","tokenized","substitutedPromises","isExpression","startsWith","endsWith","resultString","Promise","all","then","resolvedValues","join","exports"],"sources":["C:\\Users\\kaique\\Documents\\SGA\\widget\\project\\node_modules\\@tago-io\\sdk\\src\\modules\\Dictionary\\Dictionary.ts"],"sourcesContent":["import * as Papa from \"papaparse\";\r\n\r\nimport TagoIOModule from \"../../common/TagoIOModule\";\r\nimport {\r\n  IDictionaryModuleParams,\r\n  IParsedExpression,\r\n  IResolveExpressionParams,\r\n  IApplyToStringOptions,\r\n  IDictionaryModuleParamsAnonymous,\r\n} from \"./dictionary.types\";\r\nimport { LanguageData } from \"../Account/dictionaries.types\";\r\n\r\n// Regular expressions that are used for parsing the strings:\r\n// - SPLIT is used to split the string into normal words/phrases and expressions\r\n// - MATCH is used to extract the parts that compose an expression\r\nconst RE_SPLIT_EXPRESSION = /(#[A-Z0-9]+\\.[A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*#)/;\r\nconst RE_MATCH_EXPRESSION = /#([A-Z0-9]+)\\.([A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*)#/;\r\n\r\nclass Dictionary extends TagoIOModule<IDictionaryModuleParams> {\r\n  public language: string;\r\n  public runURL?: string;\r\n\r\n  constructor(params: IDictionaryModuleParams);\r\n  constructor(params: IDictionaryModuleParamsAnonymous);\r\n  constructor(params: any) {\r\n    super({ token: params?.token || \"unknown\", region: params?.region });\r\n    this.language = params?.language || \"en-US\";\r\n    this.runURL = params?.runURL;\r\n  }\r\n\r\n  /**\r\n   * Get the language data for a dictionary.\r\n   *\r\n   * @param language Language.\r\n   * @param dictionary ID or Slug.\r\n   * @param runURL URL for the Run to make anonymous request.\r\n   */\r\n  public async getLanguagesData(dictionary: string, language = this.language): Promise<LanguageData> {\r\n    if (!language || !dictionary) {\r\n      throw new Error(\"Missing parameters\");\r\n    }\r\n\r\n    try {\r\n      if (!this.runURL) {\r\n        const response = await this.doRequest<LanguageData>({\r\n          path: `/dictionary/${dictionary}/${language}`,\r\n          method: \"GET\",\r\n          cacheTTL: 3600000,\r\n          params: {\r\n            fallback: true,\r\n          },\r\n        });\r\n        return response;\r\n      } else {\r\n        const response = await TagoIOModule.doRequestAnonymous<LanguageData>({\r\n          path: `/dictionary/${this.runURL}/${dictionary}/${language}`,\r\n          method: \"GET\",\r\n          cacheTTL: 3600000,\r\n        });\r\n        return response;\r\n      }\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get value from a key in a specific dictionary for a language.\r\n   *\r\n   * @param language Name of the language (locale code).\r\n   * @param dictionary Name of the dictionary.\r\n   * @param key Name of the key.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.getValueFromKey(\"en-US\", \"TEST\", \"OK_BUTTON_LABEL\");\r\n   * ```\r\n   */\r\n  public async getValueFromKey(language: string, dictionary: string, key: string): Promise<string> {\r\n    if (!language || !dictionary || !key) {\r\n      throw new Error(\"Missing parameters\");\r\n    }\r\n\r\n    // Get the dictionary language data from the profile route or anonymous route (Run)\r\n    const languagesData = await this.getLanguagesData(dictionary, language);\r\n\r\n    // Return expression as is if the request fails or either dictionary/key do not exist\r\n    if (!languagesData || !languagesData[key]) {\r\n      return `#${dictionary}.${key}#`;\r\n    }\r\n\r\n    return languagesData[key];\r\n  }\r\n\r\n  /**\r\n   * Parse an expression and extract the names of the dictionary, the key, and\r\n   * any arguments that are passed in the expression.\r\n   *\r\n   * Returns `null` if the value passed is not parseable by the RegEx.\r\n   *\r\n   * @param expression String expression.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.parseExpression(\"#TAGORUN.WELCOME_TEXT,Hello\");\r\n   * ```\r\n   */\r\n  public parseExpression(expression: string): IParsedExpression {\r\n    const splitExpression = expression.match(RE_MATCH_EXPRESSION);\r\n    if (!splitExpression) {\r\n      return null;\r\n    }\r\n\r\n    const dictionary = splitExpression[1];\r\n    const keyWithParams = splitExpression[2];\r\n\r\n    if (expression.includes(\",\")) {\r\n      const { data } = Papa.parse<string[]>(keyWithParams);\r\n      const [key, ...params] = data[0];\r\n\r\n      return { dictionary, key, params };\r\n    }\r\n\r\n    return { dictionary, key: keyWithParams };\r\n  }\r\n\r\n  /**\r\n   * Resolve an expression in a language, replacing the parameters in the\r\n   * dictionary value with the arguments passed in the expression.\r\n   *\r\n   * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.resolveExpression({\r\n   *   language: \"en-US\",\r\n   *   expression: {\r\n   *     dictionary: \"TEST\",\r\n   *     key: \"SOME_KEY\",\r\n   *     params: [\r\n   *       \"first parameter\",\r\n   *     ],\r\n   *   },\r\n   * });\r\n   * ```\r\n   */\r\n  public async resolveExpression(resolveParams: IResolveExpressionParams): Promise<string> {\r\n    const { language, expression } = resolveParams;\r\n    const { dictionary, key, params } = expression;\r\n    let resolvedString: string;\r\n\r\n    // Get the dictionary value string for the expression to substitute the arguments into it\r\n    resolvedString = await this.getValueFromKey(language, dictionary, key);\r\n    params.forEach((substitution, index) => {\r\n      const subRegexp = new RegExp(`\\\\$${index}`, \"g\");\r\n      resolvedString = resolvedString.replace(subRegexp, substitution);\r\n    });\r\n\r\n    return resolvedString;\r\n  }\r\n\r\n  /**\r\n   * Get all (and only) the expressions in a string and their parameters if applicable,\r\n   * ignoring normal words and phrases.\r\n   *\r\n   * @param rawString String with words and/or expressions.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const expressions = dictionary.getExpressionsFromString(\"Words are ignored #TEST.DICT_KEY#\");\r\n   * ```\r\n   */\r\n  public async getExpressionsFromString(rawString: string): Promise<IParsedExpression[]> {\r\n    const tokens = rawString.split(RE_SPLIT_EXPRESSION);\r\n\r\n    const expressions = tokens\r\n      .filter((token) => RE_SPLIT_EXPRESSION.test(token))\r\n      .map((expression) => this.parseExpression(expression));\r\n\r\n    return expressions;\r\n  }\r\n\r\n  /**\r\n   * Apply the dictionary over a string, parsing the expressions in the string and\r\n   * replacing them with the values found for the respective keys inside the dictionary\r\n   * for a language.\r\n   *\r\n   * Always returns a string. Return the translated string if there are dictionary expressions,\r\n   * the raw string with no changes if there are no expressions, and an empty string if `rawString`\r\n   * is undefined.\r\n   *\r\n   * @param rawString String with words and/or expressions.\r\n   * @param options Object containing options for the dictionary, including the language.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const result = dictionary.applyToString(\"Words are ignored #TEST.DICT_KEY#\");\r\n   * ```\r\n   */\r\n  public async applyToString(rawString: string, options?: IApplyToStringOptions): Promise<string> {\r\n    const { language } = this;\r\n\r\n    // Handling undefined strings is not this function's job\r\n    if (!rawString || !language) {\r\n      return rawString || \"\";\r\n    }\r\n\r\n    // Bail early if there are no variables in the string or if the value passed\r\n    // is not a string, which can happen when not using TypeScript or passing the\r\n    // instance to a function without the type\r\n    if (typeof rawString !== \"string\" || !rawString.includes(\"#\")) {\r\n      return rawString;\r\n    }\r\n\r\n    const tokenized = rawString.split(RE_SPLIT_EXPRESSION);\r\n\r\n    const substitutedPromises = tokenized.map((token) => {\r\n      const isExpression = token.startsWith(\"#\") && token.endsWith(\"#\");\r\n      if (isExpression) {\r\n        const expression = this.parseExpression(token);\r\n        if (!expression) {\r\n          return token;\r\n        }\r\n\r\n        const { dictionary, key, params } = expression;\r\n\r\n        return params\r\n          ? this.resolveExpression({ language, expression })\r\n          : this.getValueFromKey(language, dictionary, key);\r\n      } else {\r\n        return token;\r\n      }\r\n    });\r\n\r\n    let resultString: string;\r\n    await Promise.all(substitutedPromises).then((resolvedValues) => {\r\n      resultString = resolvedValues.join(\"\");\r\n    });\r\n\r\n    return resultString;\r\n  }\r\n}\r\n\r\nexport default Dictionary;\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}