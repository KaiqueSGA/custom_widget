{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\nvar Billing = /*#__PURE__*/function (_TagoIOModule_1$defau) {\n  _inherits(Billing, _TagoIOModule_1$defau);\n  var _super = _createSuper(Billing);\n  function Billing() {\n    _classCallCheck(this, Billing);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Billing, [{\n    key: \"getSubscription\",\n    value:\n    /**\r\n     * Get the account subscription information.\r\n     */\n    function () {\n      var _getSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context.sent;\n                return _context.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getSubscription() {\n        return _getSubscription.apply(this, arguments);\n      }\n      return getSubscription;\n    }()\n    /**\r\n     * Edit an account's subscription to change plan, services or add-ons.\r\n     *\r\n     * Only one of either `plan`, `services`, or `addons` can be in `subscription`.\r\n     *\r\n     * @param subscription Object with updates to subscription.\r\n     *\r\n     * @throws If the subscription has a pending operation.\r\n     * @throws If updating more than one of plan, services and add-ons at the same time.\r\n     * @throws If purchasing add-ons or changing service limits on the Free plan.\r\n     * @throws If using an invalid coupon.\r\n     */\n  }, {\n    key: \"editSubscription\",\n    value: function () {\n      var _editSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(subscription) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription\",\n                  method: \"POST\",\n                  body: subscription\n                });\n              case 2:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function editSubscription(_x) {\n        return _editSubscription.apply(this, arguments);\n      }\n      return editSubscription;\n    }()\n    /**\r\n     * Get information for the account subscription schedule for downgrades.\r\n     *\r\n     * In the response, `subscription` reflects how the entire subscription will look\r\n     * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade\r\n     * for either plan, services or add-ons, everything is returned and not only the changes.\r\n     */\n  }, {\n    key: \"getSubscriptionSchedule\",\n    value: function () {\n      var _getSubscriptionSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription/schedule\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context3.sent;\n                return _context3.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function getSubscriptionSchedule() {\n        return _getSubscriptionSchedule.apply(this, arguments);\n      }\n      return getSubscriptionSchedule;\n    }()\n    /**\r\n     * Get pricing for plans, services and add-ons.\r\n     */\n  }, {\n    key: \"getPrices\",\n    value: function () {\n      var _getPrices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.doRequest({\n                  path: \"/pricing\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context4.sent;\n                return _context4.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function getPrices() {\n        return _getPrices.apply(this, arguments);\n      }\n      return getPrices;\n    }()\n    /**\r\n     * Get pricing for plans, services and add-ons with proration when applicable.\r\n     */\n  }, {\n    key: \"getProratedPrices\",\n    value: function () {\n      var _getProratedPrices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.doRequest({\n                  path: \"/pricing/prorated\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context5.sent;\n                return _context5.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function getProratedPrices() {\n        return _getProratedPrices.apply(this, arguments);\n      }\n      return getProratedPrices;\n    }()\n    /**\r\n     * Get information about the account's payment method credit card, credit balance,\r\n     * and the applied coupon.\r\n     */\n  }, {\n    key: \"getPaymentMethod\",\n    value: function () {\n      var _getPaymentMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.doRequest({\n                  path: \"/account/payment_method\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context6.sent;\n                return _context6.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function getPaymentMethod() {\n        return _getPaymentMethod.apply(this, arguments);\n      }\n      return getPaymentMethod;\n    }()\n    /**\r\n     * Edit an account's payment method.\r\n     *\r\n     * @param stripeCardToken Token for the new payment method added via Stripe API.\r\n     *\r\n     * @throws If token is invalid or Stripe can't create the payment method with it.\r\n     *\r\n     * @returns Success or error message.\r\n     */\n  }, {\n    key: \"editPaymentMethod\",\n    value: function () {\n      var _editPaymentMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(stripeCardToken) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.doRequest({\n                  path: \"/account/payment_method\",\n                  method: \"POST\",\n                  body: {\n                    token: stripeCardToken\n                  }\n                });\n              case 2:\n                result = _context7.sent;\n                return _context7.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function editPaymentMethod(_x2) {\n        return _editPaymentMethod.apply(this, arguments);\n      }\n      return editPaymentMethod;\n    }()\n    /**\r\n     * Remove an account's payment method from the Stripe subscription.\r\n     *\r\n     * Only removes the card if the account is on the Free plan or if it has enough credit balance.\r\n     *\r\n     * @throws If subscription is active with an upcoming invoice.\r\n     * @throws If account doesn't have a payment method.\r\n     *\r\n     * @returns Success or error message.\r\n     */\n  }, {\n    key: \"removePaymentMethod\",\n    value: function () {\n      var _removePaymentMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.doRequest({\n                  path: \"/account/payment_method\",\n                  method: \"DELETE\"\n                });\n              case 2:\n                result = _context8.sent;\n                return _context8.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function removePaymentMethod() {\n        return _removePaymentMethod.apply(this, arguments);\n      }\n      return removePaymentMethod;\n    }()\n    /**\r\n     * Get an account's billing information.\r\n     */\n  }, {\n    key: \"getBillingInformation\",\n    value: function () {\n      var _getBillingInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.doRequest({\n                  path: \"/account/billing\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context9.sent;\n                return _context9.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function getBillingInformation() {\n        return _getBillingInformation.apply(this, arguments);\n      }\n      return getBillingInformation;\n    }()\n    /**\r\n     * Edit an account's billing information.\r\n     *\r\n     * @param billingInformation Data to be updated in the account's billing information.\r\n     */\n  }, {\n    key: \"editBillingInformation\",\n    value: function () {\n      var _editBillingInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(billingInformation) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.doRequest({\n                  path: \"/account/billing\",\n                  method: \"PUT\",\n                  body: billingInformation\n                });\n              case 2:\n                result = _context10.sent;\n                return _context10.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n      function editBillingInformation(_x3) {\n        return _editBillingInformation.apply(this, arguments);\n      }\n      return editBillingInformation;\n    }()\n    /**\r\n     * Get the resource allocation for all profiles in an account.\r\n     */\n  }, {\n    key: \"getAllocation\",\n    value: function () {\n      var _getAllocation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.doRequest({\n                  path: \"/account/allocation\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context11.sent;\n                return _context11.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n      function getAllocation() {\n        return _getAllocation.apply(this, arguments);\n      }\n      return getAllocation;\n    }()\n    /**\r\n     * Edit the resource allocation for the profiles in an account.\r\n     *\r\n     * The resource allocation array doesn't need to have an object for each of the account's profiles,\r\n     * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.\r\n     *\r\n     * The resource allocation object for a profile doesn't need to have all the services.\r\n     *\r\n     * @param allocation Array with the resource allocation\r\n     *\r\n     * @throws If passed an object that is not an allocation array.\r\n     * @throws If the account only has one profile.\r\n     * @throws If one of the profile IDs in the allocation array doesn't exist in the account.\r\n     * @throws If the allocated amount for one of the services exceeds the available amount.\r\n     *\r\n     * @returns Success message.\r\n     */\n  }, {\n    key: \"editAllocation\",\n    value: function () {\n      var _editAllocation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(allocation) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.doRequest({\n                  path: \"/account/allocation\",\n                  method: \"POST\",\n                  body: allocation\n                });\n              case 2:\n                result = _context12.sent;\n                return _context12.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n      function editAllocation(_x4) {\n        return _editAllocation.apply(this, arguments);\n      }\n      return editAllocation;\n    }()\n    /**\r\n     * Get the payment history for an account.\r\n     *\r\n     * The route uses pagination and the `lastId` parameter should be the `stripe_id`\r\n     * parameter from the last history entry.\r\n     *\r\n     * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.\r\n     *\r\n     * @throws If `lastId` is passed and is invalid.\r\n     *\r\n     * @returns Array with payment history entries or an empty array when no entries are available.\r\n     */\n  }, {\n    key: \"getPaymentHistory\",\n    value: function () {\n      var _getPaymentHistory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(queryObj) {\n        var _queryObj$amount;\n        var result;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.doRequest({\n                  path: \"/account/payment_history\",\n                  method: \"GET\",\n                  params: _objectSpread({\n                    amount: (_queryObj$amount = queryObj === null || queryObj === void 0 ? void 0 : queryObj.amount) !== null && _queryObj$amount !== void 0 ? _queryObj$amount : 10\n                  }, (queryObj === null || queryObj === void 0 ? void 0 : queryObj.lastId) && {\n                    last_id: queryObj === null || queryObj === void 0 ? void 0 : queryObj.lastId\n                  })\n                });\n              case 2:\n                result = _context13.sent;\n                return _context13.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n      function getPaymentHistory(_x5) {\n        return _getPaymentHistory.apply(this, arguments);\n      }\n      return getPaymentHistory;\n    }()\n    /**\r\n     * Get a summary for important information in an account's subscription.\r\n     *\r\n     * The values returned by this route are cached.\r\n     *\r\n     * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.\r\n     */\n  }, {\n    key: \"getSubscriptionSummary\",\n    value: function () {\n      var _getSubscriptionSummary = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription/summary\",\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context14.sent;\n                return _context14.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n      function getSubscriptionSummary() {\n        return _getSubscriptionSummary.apply(this, arguments);\n      }\n      return getSubscriptionSummary;\n    }()\n    /**\r\n     * Check if a coupon is valid by its promo code.\r\n     *\r\n     * @param code Customer-facing code for the coupon (promo code).\r\n     *\r\n     * @throws If the coupon code is not valid or not found.\r\n     * @throws If coupon is specific to a an account.\r\n     * @throws If coupon can only be applied to new subscriptions.\r\n     */\n  }, {\n    key: \"checkDiscountCoupon\",\n    value: function () {\n      var _checkDiscountCoupon = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(code) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription/coupon/\".concat(code),\n                  method: \"GET\"\n                });\n              case 2:\n                result = _context15.sent;\n                return _context15.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n      function checkDiscountCoupon(_x6) {\n        return _checkDiscountCoupon.apply(this, arguments);\n      }\n      return checkDiscountCoupon;\n    }()\n    /**\r\n     * Cancel a scheduled downgrade.\r\n     *\r\n     * @throws If the subscription has no schedule.\r\n     *\r\n     * @returns Success message.\r\n     */\n  }, {\n    key: \"cancelDowngrade\",\n    value: function () {\n      var _cancelDowngrade = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription/schedule\",\n                  method: \"DELETE\"\n                });\n              case 2:\n                result = _context16.sent;\n                return _context16.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n      function cancelDowngrade() {\n        return _cancelDowngrade.apply(this, arguments);\n      }\n      return cancelDowngrade;\n    }()\n    /**\r\n     * Retry payment for an operation where the payment was unsuccessful.\r\n     *\r\n     * Works for payment errors in recurring payments or in subscription upgrade operations.\r\n     *\r\n     * @throws If account has no subscription.\r\n     * @throws If there's no pending payment.\r\n     * @throws If payment method is declined or for other payment processing errors.\r\n     *\r\n     * @returns Success message.\r\n     */\n  }, {\n    key: \"retryLastPayment\",\n    value: function () {\n      var _retryLastPayment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription/pending/retry\",\n                  method: \"POST\"\n                });\n              case 2:\n                result = _context17.sent;\n                return _context17.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n      function retryLastPayment() {\n        return _retryLastPayment.apply(this, arguments);\n      }\n      return retryLastPayment;\n    }()\n    /**\r\n     * Cancel the last pending operation if the payment has failed.\r\n     *\r\n     * Works for subscription upgrade operations and not for recurring payment errors.\r\n     *\r\n     * @throws If there's no pending payment.\r\n     *\r\n     * @returns Success message.\r\n     */\n  }, {\n    key: \"cancelLastOperation\",\n    value: function () {\n      var _cancelLastOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.doRequest({\n                  path: \"/account/subscription/pending/cancel\",\n                  method: \"POST\"\n                });\n              case 2:\n                result = _context18.sent;\n                return _context18.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n      function cancelLastOperation() {\n        return _cancelLastOperation.apply(this, arguments);\n      }\n      return cancelLastOperation;\n    }()\n  }]);\n  return Billing;\n}(TagoIOModule_1.default);\nexports.default = Billing;","map":{"version":3,"mappings":"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","names":["Billing","doRequest","path","method","result","subscription","body","stripeCardToken","token","billingInformation","allocation","queryObj","params","amount","lastId","last_id","code","TagoIOModule_1","exports"],"sources":["C:\\Users\\kaique\\Documents\\SGA\\widget\\project\\node_modules\\@tago-io\\sdk\\src\\modules\\Account\\Billing.ts"],"sourcesContent":["import { GenericID } from \"../../common/common.types\";\r\nimport TagoIOModule, { GenericModuleParams } from \"../../common/TagoIOModule\";\r\nimport type {\r\n  BillingAddOn,\r\n  BillingCoupon,\r\n  BillingEditInformation,\r\n  BillingEditResourceAllocation,\r\n  BillingEditSubscription,\r\n  BillingInformation,\r\n  BillingPaymentHistoryEntry,\r\n  BillingPaymentMethod,\r\n  BillingPrices,\r\n  BillingResourceAllocation,\r\n  BillingSchedule,\r\n  BillingSubscription,\r\n  BillingSubscriptionSummary,\r\n} from \"./billing.types\";\r\n\r\nclass Billing extends TagoIOModule<GenericModuleParams> {\r\n  /**\r\n   * Get the account subscription information.\r\n   */\r\n  public async getSubscription(): Promise<BillingSubscription> {\r\n    const result = await this.doRequest<BillingSubscription>({\r\n      path: `/account/subscription`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit an account's subscription to change plan, services or add-ons.\r\n   *\r\n   * Only one of either `plan`, `services`, or `addons` can be in `subscription`.\r\n   *\r\n   * @param subscription Object with updates to subscription.\r\n   *\r\n   * @throws If the subscription has a pending operation.\r\n   * @throws If updating more than one of plan, services and add-ons at the same time.\r\n   * @throws If purchasing add-ons or changing service limits on the Free plan.\r\n   * @throws If using an invalid coupon.\r\n   */\r\n  public async editSubscription(subscription: BillingEditSubscription): Promise<void> {\r\n    const result = await this.doRequest<void>({\r\n      path: `/account/subscription`,\r\n      method: \"POST\",\r\n      body: subscription,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get information for the account subscription schedule for downgrades.\r\n   *\r\n   * In the response, `subscription` reflects how the entire subscription will look\r\n   * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade\r\n   * for either plan, services or add-ons, everything is returned and not only the changes.\r\n   */\r\n  public async getSubscriptionSchedule(): Promise<BillingSchedule> {\r\n    const result = await this.doRequest<BillingSchedule>({\r\n      path: `/account/subscription/schedule`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get pricing for plans, services and add-ons.\r\n   */\r\n  public async getPrices(): Promise<BillingPrices> {\r\n    const result = await this.doRequest<BillingPrices>({\r\n      path: `/pricing`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get pricing for plans, services and add-ons with proration when applicable.\r\n   */\r\n  public async getProratedPrices(): Promise<BillingPrices> {\r\n    const result = await this.doRequest<BillingPrices>({\r\n      path: `/pricing/prorated`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get information about the account's payment method credit card, credit balance,\r\n   * and the applied coupon.\r\n   */\r\n  public async getPaymentMethod(): Promise<BillingPaymentMethod> {\r\n    const result = await this.doRequest<BillingPaymentMethod>({\r\n      path: `/account/payment_method`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit an account's payment method.\r\n   *\r\n   * @param stripeCardToken Token for the new payment method added via Stripe API.\r\n   *\r\n   * @throws If token is invalid or Stripe can't create the payment method with it.\r\n   *\r\n   * @returns Success or error message.\r\n   */\r\n  public async editPaymentMethod(stripeCardToken: string): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/payment_method`,\r\n      method: \"POST\",\r\n      body: { token: stripeCardToken },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Remove an account's payment method from the Stripe subscription.\r\n   *\r\n   * Only removes the card if the account is on the Free plan or if it has enough credit balance.\r\n   *\r\n   * @throws If subscription is active with an upcoming invoice.\r\n   * @throws If account doesn't have a payment method.\r\n   *\r\n   * @returns Success or error message.\r\n   */\r\n  public async removePaymentMethod(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/payment_method`,\r\n      method: \"DELETE\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get an account's billing information.\r\n   */\r\n  public async getBillingInformation(): Promise<BillingInformation> {\r\n    const result = await this.doRequest<BillingInformation>({\r\n      path: `/account/billing`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit an account's billing information.\r\n   *\r\n   * @param billingInformation Data to be updated in the account's billing information.\r\n   */\r\n  public async editBillingInformation(billingInformation: BillingEditInformation): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/billing`,\r\n      method: \"PUT\",\r\n      body: billingInformation,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get the resource allocation for all profiles in an account.\r\n   */\r\n  public async getAllocation(): Promise<BillingResourceAllocation> {\r\n    const result = await this.doRequest<BillingResourceAllocation>({\r\n      path: `/account/allocation`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit the resource allocation for the profiles in an account.\r\n   *\r\n   * The resource allocation array doesn't need to have an object for each of the account's profiles,\r\n   * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.\r\n   *\r\n   * The resource allocation object for a profile doesn't need to have all the services.\r\n   *\r\n   * @param allocation Array with the resource allocation\r\n   *\r\n   * @throws If passed an object that is not an allocation array.\r\n   * @throws If the account only has one profile.\r\n   * @throws If one of the profile IDs in the allocation array doesn't exist in the account.\r\n   * @throws If the allocated amount for one of the services exceeds the available amount.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async editAllocation(allocation: BillingEditResourceAllocation): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/allocation`,\r\n      method: \"POST\",\r\n      body: allocation,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get the payment history for an account.\r\n   *\r\n   * The route uses pagination and the `lastId` parameter should be the `stripe_id`\r\n   * parameter from the last history entry.\r\n   *\r\n   * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.\r\n   *\r\n   * @throws If `lastId` is passed and is invalid.\r\n   *\r\n   * @returns Array with payment history entries or an empty array when no entries are available.\r\n   */\r\n  public async getPaymentHistory(queryObj?: {\r\n    amount?: number;\r\n    lastId?: string;\r\n  }): Promise<BillingPaymentHistoryEntry[]> {\r\n    const result = await this.doRequest<BillingPaymentHistoryEntry[]>({\r\n      path: `/account/payment_history`,\r\n      method: \"GET\",\r\n      params: {\r\n        amount: queryObj?.amount ?? 10,\r\n        ...(queryObj?.lastId && { last_id: queryObj?.lastId }),\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get a summary for important information in an account's subscription.\r\n   *\r\n   * The values returned by this route are cached.\r\n   *\r\n   * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.\r\n   */\r\n  public async getSubscriptionSummary(): Promise<BillingSubscriptionSummary | undefined> {\r\n    const result = await this.doRequest<BillingSubscriptionSummary | undefined>({\r\n      path: `/account/subscription/summary`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if a coupon is valid by its promo code.\r\n   *\r\n   * @param code Customer-facing code for the coupon (promo code).\r\n   *\r\n   * @throws If the coupon code is not valid or not found.\r\n   * @throws If coupon is specific to a an account.\r\n   * @throws If coupon can only be applied to new subscriptions.\r\n   */\r\n  public async checkDiscountCoupon(code?: string): Promise<BillingCoupon> {\r\n    const result = await this.doRequest<BillingCoupon>({\r\n      path: `/account/subscription/coupon/${code}`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Cancel a scheduled downgrade.\r\n   *\r\n   * @throws If the subscription has no schedule.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async cancelDowngrade(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/subscription/schedule`,\r\n      method: \"DELETE\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Retry payment for an operation where the payment was unsuccessful.\r\n   *\r\n   * Works for payment errors in recurring payments or in subscription upgrade operations.\r\n   *\r\n   * @throws If account has no subscription.\r\n   * @throws If there's no pending payment.\r\n   * @throws If payment method is declined or for other payment processing errors.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async retryLastPayment(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/subscription/pending/retry`,\r\n      method: \"POST\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Cancel the last pending operation if the payment has failed.\r\n   *\r\n   * Works for subscription upgrade operations and not for recurring payment errors.\r\n   *\r\n   * @throws If there's no pending payment.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async cancelLastOperation(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/subscription/pending/cancel`,\r\n      method: \"POST\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Billing;\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}