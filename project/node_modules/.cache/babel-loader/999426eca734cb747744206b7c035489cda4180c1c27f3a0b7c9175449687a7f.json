{"ast":null,"code":"\"use strict\";\n\nvar _toArray = require(\"C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/mqtt_wid/dash_mqtt/node_modules/@babel/runtime/helpers/toArray.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/mqtt_wid/dash_mqtt/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/mqtt_wid/dash_mqtt/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/mqtt_wid/dash_mqtt/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/mqtt_wid/dash_mqtt/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/mqtt_wid/dash_mqtt/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/mqtt_wid/dash_mqtt/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Papa = __importStar(require(\"papaparse\"));\nvar TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\n// Regular expressions that are used for parsing the strings:\n// - SPLIT is used to split the string into normal words/phrases and expressions\n// - MATCH is used to extract the parts that compose an expression\nvar RE_SPLIT_EXPRESSION = /(#[A-Z0-9]+\\.[A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*#)/;\nvar RE_MATCH_EXPRESSION = /#([A-Z0-9]+)\\.([A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*)#/;\nvar Dictionary = /*#__PURE__*/function (_TagoIOModule_1$defau) {\n  _inherits(Dictionary, _TagoIOModule_1$defau);\n  var _super = _createSuper(Dictionary);\n  function Dictionary(params) {\n    var _this;\n    _classCallCheck(this, Dictionary);\n    _this = _super.call(this, {\n      token: (params === null || params === void 0 ? void 0 : params.token) || \"unknown\",\n      region: params === null || params === void 0 ? void 0 : params.region\n    });\n    _this.language = (params === null || params === void 0 ? void 0 : params.language) || \"en-US\";\n    _this.runURL = params === null || params === void 0 ? void 0 : params.runURL;\n    return _this;\n  }\n  /**\n   * Get the language data for a dictionary.\n   *\n   * @param language Language.\n   * @param dictionary ID or Slug.\n   * @param runURL URL for the Run to make anonymous request.\n   */\n  _createClass(Dictionary, [{\n    key: \"getLanguagesData\",\n    value: function () {\n      var _getLanguagesData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dictionary) {\n        var language,\n          response,\n          _response,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                language = _args.length > 1 && _args[1] !== undefined ? _args[1] : this.language;\n                if (!(!language || !dictionary)) {\n                  _context.next = 3;\n                  break;\n                }\n                throw new Error(\"Missing parameters\");\n              case 3:\n                _context.prev = 3;\n                if (this.runURL) {\n                  _context.next = 11;\n                  break;\n                }\n                _context.next = 7;\n                return this.doRequest({\n                  path: \"/dictionary/\".concat(dictionary, \"/\").concat(language),\n                  method: \"GET\",\n                  cacheTTL: 3600000,\n                  params: {\n                    fallback: true\n                  }\n                });\n              case 7:\n                response = _context.sent;\n                return _context.abrupt(\"return\", response);\n              case 11:\n                _context.next = 13;\n                return TagoIOModule_1.default.doRequestAnonymous({\n                  path: \"/dictionary/\".concat(this.runURL, \"/\").concat(dictionary, \"/\").concat(language),\n                  method: \"GET\",\n                  cacheTTL: 3600000\n                });\n              case 13:\n                _response = _context.sent;\n                return _context.abrupt(\"return\", _response);\n              case 15:\n                _context.next = 20;\n                break;\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](3);\n                return _context.abrupt(\"return\", null);\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 17]]);\n      }));\n      function getLanguagesData(_x) {\n        return _getLanguagesData.apply(this, arguments);\n      }\n      return getLanguagesData;\n    }()\n    /**\n     * Get value from a key in a specific dictionary for a language.\n     *\n     * @param language Name of the language (locale code).\n     * @param dictionary Name of the dictionary.\n     * @param key Name of the key.\n     *\n     * @example\n     * ```\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n     * const value = dictionary.getValueFromKey(\"en-US\", \"TEST\", \"OK_BUTTON_LABEL\");\n     * ```\n     */\n  }, {\n    key: \"getValueFromKey\",\n    value: function () {\n      var _getValueFromKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(language, dictionary, key) {\n        var languagesData;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(!language || !dictionary || !key)) {\n                  _context2.next = 2;\n                  break;\n                }\n                throw new Error(\"Missing parameters\");\n              case 2:\n                _context2.next = 4;\n                return this.getLanguagesData(dictionary, language);\n              case 4:\n                languagesData = _context2.sent;\n                if (!(!languagesData || !languagesData[key])) {\n                  _context2.next = 7;\n                  break;\n                }\n                return _context2.abrupt(\"return\", \"#\".concat(dictionary, \".\").concat(key, \"#\"));\n              case 7:\n                return _context2.abrupt(\"return\", languagesData[key]);\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function getValueFromKey(_x2, _x3, _x4) {\n        return _getValueFromKey.apply(this, arguments);\n      }\n      return getValueFromKey;\n    }()\n    /**\n     * Parse an expression and extract the names of the dictionary, the key, and\n     * any arguments that are passed in the expression.\n     *\n     * Returns `null` if the value passed is not parseable by the RegEx.\n     *\n     * @param expression String expression.\n     *\n     * @example\n     * ```\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n     * const value = dictionary.parseExpression(\"#TAGORUN.WELCOME_TEXT,Hello\");\n     * ```\n     */\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression(expression) {\n      var splitExpression = expression.match(RE_MATCH_EXPRESSION);\n      if (!splitExpression) {\n        return null;\n      }\n      var dictionary = splitExpression[1];\n      var keyWithParams = splitExpression[2];\n      if (expression.includes(\",\")) {\n        var _Papa$parse = Papa.parse(keyWithParams),\n          data = _Papa$parse.data;\n        var _data$ = _toArray(data[0]),\n          key = _data$[0],\n          params = _data$.slice(1);\n        return {\n          dictionary: dictionary,\n          key: key,\n          params: params\n        };\n      }\n      return {\n        dictionary: dictionary,\n        key: keyWithParams\n      };\n    }\n    /**\n     * Resolve an expression in a language, replacing the parameters in the\n     * dictionary value with the arguments passed in the expression.\n     *\n     * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).\n     *\n     * @example\n     * ```\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n     * const value = dictionary.resolveExpression({\n     *   language: \"en-US\",\n     *   expression: {\n     *     dictionary: \"TEST\",\n     *     key: \"SOME_KEY\",\n     *     params: [\n     *       \"first parameter\",\n     *     ],\n     *   },\n     * });\n     * ```\n     */\n  }, {\n    key: \"resolveExpression\",\n    value: function () {\n      var _resolveExpression = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolveParams) {\n        var language, expression, dictionary, key, params, resolvedString;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                language = resolveParams.language, expression = resolveParams.expression;\n                dictionary = expression.dictionary, key = expression.key, params = expression.params;\n                _context3.next = 4;\n                return this.getValueFromKey(language, dictionary, key);\n              case 4:\n                resolvedString = _context3.sent;\n                params.forEach(function (substitution, index) {\n                  var subRegexp = new RegExp(\"\\\\$\".concat(index), \"g\");\n                  resolvedString = resolvedString.replace(subRegexp, substitution);\n                });\n                return _context3.abrupt(\"return\", resolvedString);\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function resolveExpression(_x5) {\n        return _resolveExpression.apply(this, arguments);\n      }\n      return resolveExpression;\n    }()\n    /**\n     * Get all (and only) the expressions in a string and their parameters if applicable,\n     * ignoring normal words and phrases.\n     *\n     * @param rawString String with words and/or expressions.\n     *\n     * @example\n     * ```\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n     * const expressions = dictionary.getExpressionsFromString(\"Words are ignored #TEST.DICT_KEY#\");\n     * ```\n     */\n  }, {\n    key: \"getExpressionsFromString\",\n    value: function () {\n      var _getExpressionsFromString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(rawString) {\n        var _this2 = this;\n        var tokens, expressions;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                tokens = rawString.split(RE_SPLIT_EXPRESSION);\n                expressions = tokens.filter(function (token) {\n                  return RE_SPLIT_EXPRESSION.test(token);\n                }).map(function (expression) {\n                  return _this2.parseExpression(expression);\n                });\n                return _context4.abrupt(\"return\", expressions);\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      function getExpressionsFromString(_x6) {\n        return _getExpressionsFromString.apply(this, arguments);\n      }\n      return getExpressionsFromString;\n    }()\n    /**\n     * Apply the dictionary over a string, parsing the expressions in the string and\n     * replacing them with the values found for the respective keys inside the dictionary\n     * for a language.\n     *\n     * Always returns a string. Return the translated string if there are dictionary expressions,\n     * the raw string with no changes if there are no expressions, and an empty string if `rawString`\n     * is undefined.\n     *\n     * @param rawString String with words and/or expressions.\n     * @param options Object containing options for the dictionary, including the language.\n     *\n     * @example\n     * ```\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n     * const result = dictionary.applyToString(\"Words are ignored #TEST.DICT_KEY#\");\n     * ```\n     */\n  }, {\n    key: \"applyToString\",\n    value: function () {\n      var _applyToString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(rawString, options) {\n        var _this3 = this;\n        var language, tokenized, substitutedPromises, resultString;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                language = this.language; // Handling undefined strings is not this function's job\n                if (!(!rawString || !language)) {\n                  _context5.next = 3;\n                  break;\n                }\n                return _context5.abrupt(\"return\", rawString || \"\");\n              case 3:\n                if (!(typeof rawString !== \"string\" || !rawString.includes(\"#\"))) {\n                  _context5.next = 5;\n                  break;\n                }\n                return _context5.abrupt(\"return\", rawString);\n              case 5:\n                tokenized = rawString.split(RE_SPLIT_EXPRESSION);\n                substitutedPromises = tokenized.map(function (token) {\n                  var isExpression = token.startsWith(\"#\") && token.endsWith(\"#\");\n                  if (isExpression) {\n                    var expression = _this3.parseExpression(token);\n                    if (!expression) {\n                      return token;\n                    }\n                    var dictionary = expression.dictionary,\n                      key = expression.key,\n                      params = expression.params;\n                    return params ? _this3.resolveExpression({\n                      language: language,\n                      expression: expression\n                    }) : _this3.getValueFromKey(language, dictionary, key);\n                  } else {\n                    return token;\n                  }\n                });\n                _context5.next = 9;\n                return Promise.all(substitutedPromises).then(function (resolvedValues) {\n                  resultString = resolvedValues.join(\"\");\n                });\n              case 9:\n                return _context5.abrupt(\"return\", resultString);\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function applyToString(_x7, _x8) {\n        return _applyToString.apply(this, arguments);\n      }\n      return applyToString;\n    }()\n  }]);\n  return Dictionary;\n}(TagoIOModule_1.default);\nexports.default = Dictionary;","map":{"version":3,"mappings":"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","names":["RE_SPLIT_EXPRESSION","RE_MATCH_EXPRESSION","Dictionary","params","token","region","language","runURL","dictionary","Error","doRequest","path","method","cacheTTL","fallback","response","TagoIOModule_1","doRequestAnonymous","key","getLanguagesData","languagesData","expression","splitExpression","match","keyWithParams","includes","Papa","parse","data","resolveParams","getValueFromKey","resolvedString","forEach","substitution","index","subRegexp","RegExp","replace","rawString","tokens","split","expressions","filter","test","map","parseExpression","options","tokenized","substitutedPromises","isExpression","startsWith","endsWith","resolveExpression","Promise","all","then","resolvedValues","resultString","join","exports"],"sources":["C:\\Users\\yudji\\OneDrive\\Documentos\\SGA\\WIDGETS\\mqtt_wid\\dash_mqtt\\node_modules\\@tago-io\\sdk\\src\\modules\\Dictionary\\Dictionary.ts"],"sourcesContent":["import * as Papa from \"papaparse\";\n\nimport TagoIOModule from \"../../common/TagoIOModule\";\nimport {\n  IDictionaryModuleParams,\n  IParsedExpression,\n  IResolveExpressionParams,\n  IApplyToStringOptions,\n  IDictionaryModuleParamsAnonymous,\n} from \"./dictionary.types\";\nimport { LanguageData } from \"../Account/dictionaries.types\";\n\n// Regular expressions that are used for parsing the strings:\n// - SPLIT is used to split the string into normal words/phrases and expressions\n// - MATCH is used to extract the parts that compose an expression\nconst RE_SPLIT_EXPRESSION = /(#[A-Z0-9]+\\.[A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*#)/;\nconst RE_MATCH_EXPRESSION = /#([A-Z0-9]+)\\.([A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*)#/;\n\nclass Dictionary extends TagoIOModule<IDictionaryModuleParams> {\n  public language: string;\n  public runURL?: string;\n\n  constructor(params: IDictionaryModuleParams);\n  constructor(params: IDictionaryModuleParamsAnonymous);\n  constructor(params: any) {\n    super({ token: params?.token || \"unknown\", region: params?.region });\n    this.language = params?.language || \"en-US\";\n    this.runURL = params?.runURL;\n  }\n\n  /**\n   * Get the language data for a dictionary.\n   *\n   * @param language Language.\n   * @param dictionary ID or Slug.\n   * @param runURL URL for the Run to make anonymous request.\n   */\n  public async getLanguagesData(dictionary: string, language = this.language): Promise<LanguageData> {\n    if (!language || !dictionary) {\n      throw new Error(\"Missing parameters\");\n    }\n\n    try {\n      if (!this.runURL) {\n        const response = await this.doRequest<LanguageData>({\n          path: `/dictionary/${dictionary}/${language}`,\n          method: \"GET\",\n          cacheTTL: 3600000,\n          params: {\n            fallback: true,\n          },\n        });\n        return response;\n      } else {\n        const response = await TagoIOModule.doRequestAnonymous<LanguageData>({\n          path: `/dictionary/${this.runURL}/${dictionary}/${language}`,\n          method: \"GET\",\n          cacheTTL: 3600000,\n        });\n        return response;\n      }\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Get value from a key in a specific dictionary for a language.\n   *\n   * @param language Name of the language (locale code).\n   * @param dictionary Name of the dictionary.\n   * @param key Name of the key.\n   *\n   * @example\n   * ```\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n   * const value = dictionary.getValueFromKey(\"en-US\", \"TEST\", \"OK_BUTTON_LABEL\");\n   * ```\n   */\n  public async getValueFromKey(language: string, dictionary: string, key: string): Promise<string> {\n    if (!language || !dictionary || !key) {\n      throw new Error(\"Missing parameters\");\n    }\n\n    // Get the dictionary language data from the profile route or anonymous route (Run)\n    const languagesData = await this.getLanguagesData(dictionary, language);\n\n    // Return expression as is if the request fails or either dictionary/key do not exist\n    if (!languagesData || !languagesData[key]) {\n      return `#${dictionary}.${key}#`;\n    }\n\n    return languagesData[key];\n  }\n\n  /**\n   * Parse an expression and extract the names of the dictionary, the key, and\n   * any arguments that are passed in the expression.\n   *\n   * Returns `null` if the value passed is not parseable by the RegEx.\n   *\n   * @param expression String expression.\n   *\n   * @example\n   * ```\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n   * const value = dictionary.parseExpression(\"#TAGORUN.WELCOME_TEXT,Hello\");\n   * ```\n   */\n  public parseExpression(expression: string): IParsedExpression {\n    const splitExpression = expression.match(RE_MATCH_EXPRESSION);\n    if (!splitExpression) {\n      return null;\n    }\n\n    const dictionary = splitExpression[1];\n    const keyWithParams = splitExpression[2];\n\n    if (expression.includes(\",\")) {\n      const { data } = Papa.parse<string[]>(keyWithParams);\n      const [key, ...params] = data[0];\n\n      return { dictionary, key, params };\n    }\n\n    return { dictionary, key: keyWithParams };\n  }\n\n  /**\n   * Resolve an expression in a language, replacing the parameters in the\n   * dictionary value with the arguments passed in the expression.\n   *\n   * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).\n   *\n   * @example\n   * ```\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n   * const value = dictionary.resolveExpression({\n   *   language: \"en-US\",\n   *   expression: {\n   *     dictionary: \"TEST\",\n   *     key: \"SOME_KEY\",\n   *     params: [\n   *       \"first parameter\",\n   *     ],\n   *   },\n   * });\n   * ```\n   */\n  public async resolveExpression(resolveParams: IResolveExpressionParams): Promise<string> {\n    const { language, expression } = resolveParams;\n    const { dictionary, key, params } = expression;\n    let resolvedString: string;\n\n    // Get the dictionary value string for the expression to substitute the arguments into it\n    resolvedString = await this.getValueFromKey(language, dictionary, key);\n    params.forEach((substitution, index) => {\n      const subRegexp = new RegExp(`\\\\$${index}`, \"g\");\n      resolvedString = resolvedString.replace(subRegexp, substitution);\n    });\n\n    return resolvedString;\n  }\n\n  /**\n   * Get all (and only) the expressions in a string and their parameters if applicable,\n   * ignoring normal words and phrases.\n   *\n   * @param rawString String with words and/or expressions.\n   *\n   * @example\n   * ```\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n   * const expressions = dictionary.getExpressionsFromString(\"Words are ignored #TEST.DICT_KEY#\");\n   * ```\n   */\n  public async getExpressionsFromString(rawString: string): Promise<IParsedExpression[]> {\n    const tokens = rawString.split(RE_SPLIT_EXPRESSION);\n\n    const expressions = tokens\n      .filter((token) => RE_SPLIT_EXPRESSION.test(token))\n      .map((expression) => this.parseExpression(expression));\n\n    return expressions;\n  }\n\n  /**\n   * Apply the dictionary over a string, parsing the expressions in the string and\n   * replacing them with the values found for the respective keys inside the dictionary\n   * for a language.\n   *\n   * Always returns a string. Return the translated string if there are dictionary expressions,\n   * the raw string with no changes if there are no expressions, and an empty string if `rawString`\n   * is undefined.\n   *\n   * @param rawString String with words and/or expressions.\n   * @param options Object containing options for the dictionary, including the language.\n   *\n   * @example\n   * ```\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\n   * const result = dictionary.applyToString(\"Words are ignored #TEST.DICT_KEY#\");\n   * ```\n   */\n  public async applyToString(rawString: string, options?: IApplyToStringOptions): Promise<string> {\n    const { language } = this;\n\n    // Handling undefined strings is not this function's job\n    if (!rawString || !language) {\n      return rawString || \"\";\n    }\n\n    // Bail early if there are no variables in the string or if the value passed\n    // is not a string, which can happen when not using TypeScript or passing the\n    // instance to a function without the type\n    if (typeof rawString !== \"string\" || !rawString.includes(\"#\")) {\n      return rawString;\n    }\n\n    const tokenized = rawString.split(RE_SPLIT_EXPRESSION);\n\n    const substitutedPromises = tokenized.map((token) => {\n      const isExpression = token.startsWith(\"#\") && token.endsWith(\"#\");\n      if (isExpression) {\n        const expression = this.parseExpression(token);\n        if (!expression) {\n          return token;\n        }\n\n        const { dictionary, key, params } = expression;\n\n        return params\n          ? this.resolveExpression({ language, expression })\n          : this.getValueFromKey(language, dictionary, key);\n      } else {\n        return token;\n      }\n    });\n\n    let resultString: string;\n    await Promise.all(substitutedPromises).then((resolvedValues) => {\n      resultString = resolvedValues.join(\"\");\n    });\n\n    return resultString;\n  }\n}\n\nexport default Dictionary;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}