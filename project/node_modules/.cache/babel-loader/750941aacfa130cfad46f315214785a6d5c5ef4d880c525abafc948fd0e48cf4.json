{"ast":null,"code":"\"use strict\";\n\nvar _toArray = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/toArray.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Papa = __importStar(require(\"papaparse\"));\nvar TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\n// Regular expressions that are used for parsing the strings:\n// - SPLIT is used to split the string into normal words/phrases and expressions\n// - MATCH is used to extract the parts that compose an expression\nvar RE_SPLIT_EXPRESSION = /(#[A-Z0-9]+\\.[A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*#)/;\nvar RE_MATCH_EXPRESSION = /#([A-Z0-9]+)\\.([A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*)#/;\nvar Dictionary = /*#__PURE__*/function (_TagoIOModule_1$defau) {\n  _inherits(Dictionary, _TagoIOModule_1$defau);\n  var _super = _createSuper(Dictionary);\n  function Dictionary(params) {\n    var _this;\n    _classCallCheck(this, Dictionary);\n    _this = _super.call(this, {\n      token: (params === null || params === void 0 ? void 0 : params.token) || \"unknown\",\n      region: params === null || params === void 0 ? void 0 : params.region\n    });\n    _this.language = (params === null || params === void 0 ? void 0 : params.language) || \"en-US\";\n    _this.runURL = params === null || params === void 0 ? void 0 : params.runURL;\n    return _this;\n  }\n  /**\r\n   * Get the language data for a dictionary.\r\n   *\r\n   * @param language Language.\r\n   * @param dictionary ID or Slug.\r\n   * @param runURL URL for the Run to make anonymous request.\r\n   */\n  _createClass(Dictionary, [{\n    key: \"getLanguagesData\",\n    value: function () {\n      var _getLanguagesData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dictionary) {\n        var language,\n          response,\n          _response,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                language = _args.length > 1 && _args[1] !== undefined ? _args[1] : this.language;\n                if (!(!language || !dictionary)) {\n                  _context.next = 3;\n                  break;\n                }\n                throw new Error(\"Missing parameters\");\n              case 3:\n                _context.prev = 3;\n                if (this.runURL) {\n                  _context.next = 11;\n                  break;\n                }\n                _context.next = 7;\n                return this.doRequest({\n                  path: \"/dictionary/\".concat(dictionary, \"/\").concat(language),\n                  method: \"GET\",\n                  cacheTTL: 3600000,\n                  params: {\n                    fallback: true\n                  }\n                });\n              case 7:\n                response = _context.sent;\n                return _context.abrupt(\"return\", response);\n              case 11:\n                _context.next = 13;\n                return TagoIOModule_1.default.doRequestAnonymous({\n                  path: \"/dictionary/\".concat(this.runURL, \"/\").concat(dictionary, \"/\").concat(language),\n                  method: \"GET\",\n                  cacheTTL: 3600000\n                });\n              case 13:\n                _response = _context.sent;\n                return _context.abrupt(\"return\", _response);\n              case 15:\n                _context.next = 20;\n                break;\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](3);\n                return _context.abrupt(\"return\", null);\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 17]]);\n      }));\n      function getLanguagesData(_x) {\n        return _getLanguagesData.apply(this, arguments);\n      }\n      return getLanguagesData;\n    }()\n    /**\r\n     * Get value from a key in a specific dictionary for a language.\r\n     *\r\n     * @param language Name of the language (locale code).\r\n     * @param dictionary Name of the dictionary.\r\n     * @param key Name of the key.\r\n     *\r\n     * @example\r\n     * ```\r\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n     * const value = dictionary.getValueFromKey(\"en-US\", \"TEST\", \"OK_BUTTON_LABEL\");\r\n     * ```\r\n     */\n  }, {\n    key: \"getValueFromKey\",\n    value: function () {\n      var _getValueFromKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(language, dictionary, key) {\n        var languagesData;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(!language || !dictionary || !key)) {\n                  _context2.next = 2;\n                  break;\n                }\n                throw new Error(\"Missing parameters\");\n              case 2:\n                _context2.next = 4;\n                return this.getLanguagesData(dictionary, language);\n              case 4:\n                languagesData = _context2.sent;\n                if (!(!languagesData || !languagesData[key])) {\n                  _context2.next = 7;\n                  break;\n                }\n                return _context2.abrupt(\"return\", \"#\".concat(dictionary, \".\").concat(key, \"#\"));\n              case 7:\n                return _context2.abrupt(\"return\", languagesData[key]);\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function getValueFromKey(_x2, _x3, _x4) {\n        return _getValueFromKey.apply(this, arguments);\n      }\n      return getValueFromKey;\n    }()\n    /**\r\n     * Parse an expression and extract the names of the dictionary, the key, and\r\n     * any arguments that are passed in the expression.\r\n     *\r\n     * Returns `null` if the value passed is not parseable by the RegEx.\r\n     *\r\n     * @param expression String expression.\r\n     *\r\n     * @example\r\n     * ```\r\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n     * const value = dictionary.parseExpression(\"#TAGORUN.WELCOME_TEXT,Hello\");\r\n     * ```\r\n     */\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression(expression) {\n      var splitExpression = expression.match(RE_MATCH_EXPRESSION);\n      if (!splitExpression) {\n        return null;\n      }\n      var dictionary = splitExpression[1];\n      var keyWithParams = splitExpression[2];\n      if (expression.includes(\",\")) {\n        var _Papa$parse = Papa.parse(keyWithParams),\n          data = _Papa$parse.data;\n        var _data$ = _toArray(data[0]),\n          key = _data$[0],\n          params = _data$.slice(1);\n        return {\n          dictionary: dictionary,\n          key: key,\n          params: params\n        };\n      }\n      return {\n        dictionary: dictionary,\n        key: keyWithParams\n      };\n    }\n    /**\r\n     * Resolve an expression in a language, replacing the parameters in the\r\n     * dictionary value with the arguments passed in the expression.\r\n     *\r\n     * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).\r\n     *\r\n     * @example\r\n     * ```\r\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n     * const value = dictionary.resolveExpression({\r\n     *   language: \"en-US\",\r\n     *   expression: {\r\n     *     dictionary: \"TEST\",\r\n     *     key: \"SOME_KEY\",\r\n     *     params: [\r\n     *       \"first parameter\",\r\n     *     ],\r\n     *   },\r\n     * });\r\n     * ```\r\n     */\n  }, {\n    key: \"resolveExpression\",\n    value: function () {\n      var _resolveExpression = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolveParams) {\n        var language, expression, dictionary, key, params, resolvedString;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                language = resolveParams.language, expression = resolveParams.expression;\n                dictionary = expression.dictionary, key = expression.key, params = expression.params;\n                _context3.next = 4;\n                return this.getValueFromKey(language, dictionary, key);\n              case 4:\n                resolvedString = _context3.sent;\n                params.forEach(function (substitution, index) {\n                  var subRegexp = new RegExp(\"\\\\$\".concat(index), \"g\");\n                  resolvedString = resolvedString.replace(subRegexp, substitution);\n                });\n                return _context3.abrupt(\"return\", resolvedString);\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function resolveExpression(_x5) {\n        return _resolveExpression.apply(this, arguments);\n      }\n      return resolveExpression;\n    }()\n    /**\r\n     * Get all (and only) the expressions in a string and their parameters if applicable,\r\n     * ignoring normal words and phrases.\r\n     *\r\n     * @param rawString String with words and/or expressions.\r\n     *\r\n     * @example\r\n     * ```\r\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n     * const expressions = dictionary.getExpressionsFromString(\"Words are ignored #TEST.DICT_KEY#\");\r\n     * ```\r\n     */\n  }, {\n    key: \"getExpressionsFromString\",\n    value: function () {\n      var _getExpressionsFromString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(rawString) {\n        var _this2 = this;\n        var tokens, expressions;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                tokens = rawString.split(RE_SPLIT_EXPRESSION);\n                expressions = tokens.filter(function (token) {\n                  return RE_SPLIT_EXPRESSION.test(token);\n                }).map(function (expression) {\n                  return _this2.parseExpression(expression);\n                });\n                return _context4.abrupt(\"return\", expressions);\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      function getExpressionsFromString(_x6) {\n        return _getExpressionsFromString.apply(this, arguments);\n      }\n      return getExpressionsFromString;\n    }()\n    /**\r\n     * Apply the dictionary over a string, parsing the expressions in the string and\r\n     * replacing them with the values found for the respective keys inside the dictionary\r\n     * for a language.\r\n     *\r\n     * Always returns a string. Return the translated string if there are dictionary expressions,\r\n     * the raw string with no changes if there are no expressions, and an empty string if `rawString`\r\n     * is undefined.\r\n     *\r\n     * @param rawString String with words and/or expressions.\r\n     * @param options Object containing options for the dictionary, including the language.\r\n     *\r\n     * @example\r\n     * ```\r\n     * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n     * const result = dictionary.applyToString(\"Words are ignored #TEST.DICT_KEY#\");\r\n     * ```\r\n     */\n  }, {\n    key: \"applyToString\",\n    value: function () {\n      var _applyToString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(rawString, options) {\n        var _this3 = this;\n        var language, tokenized, substitutedPromises, resultString;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                language = this.language; // Handling undefined strings is not this function's job\n                if (!(!rawString || !language)) {\n                  _context5.next = 3;\n                  break;\n                }\n                return _context5.abrupt(\"return\", rawString || \"\");\n              case 3:\n                if (!(typeof rawString !== \"string\" || !rawString.includes(\"#\"))) {\n                  _context5.next = 5;\n                  break;\n                }\n                return _context5.abrupt(\"return\", rawString);\n              case 5:\n                tokenized = rawString.split(RE_SPLIT_EXPRESSION);\n                substitutedPromises = tokenized.map(function (token) {\n                  var isExpression = token.startsWith(\"#\") && token.endsWith(\"#\");\n                  if (isExpression) {\n                    var expression = _this3.parseExpression(token);\n                    if (!expression) {\n                      return token;\n                    }\n                    var dictionary = expression.dictionary,\n                      key = expression.key,\n                      params = expression.params;\n                    return params ? _this3.resolveExpression({\n                      language: language,\n                      expression: expression\n                    }) : _this3.getValueFromKey(language, dictionary, key);\n                  } else {\n                    return token;\n                  }\n                });\n                _context5.next = 9;\n                return Promise.all(substitutedPromises).then(function (resolvedValues) {\n                  resultString = resolvedValues.join(\"\");\n                });\n              case 9:\n                return _context5.abrupt(\"return\", resultString);\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function applyToString(_x7, _x8) {\n        return _applyToString.apply(this, arguments);\n      }\n      return applyToString;\n    }()\n  }]);\n  return Dictionary;\n}(TagoIOModule_1.default);\nexports.default = Dictionary;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AAUA;AACA;AACA;AACA,IAAMA,mBAAmB,GAAG,wDAAwD;AACpF,IAAMC,mBAAmB,GAAG,0DAA0D;AAAC,IAEjFC,UAAW;EAAA;EAAA;EAMf,oBAAYC,MAAW;IAAA;IAAA;IACrB,0BAAM;MAAEC,KAAK,EAAE,OAAM,aAAND,MAAM,uBAANA,MAAM,CAAEC,KAAK,KAAI,SAAS;MAAEC,MAAM,EAAEF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE;IAAM,CAAE;IACnE,MAAKC,QAAQ,GAAG,OAAM,aAANH,MAAM,uBAANA,MAAM,CAAEG,QAAQ,KAAI,OAAO;IAC3C,MAAKC,MAAM,GAAGJ,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEI,MAAM;IAAC;EAC/B;EAEA;;;;;;;EAAA;IAAA;IAAA;MAAA,mFAOO,iBAAuBC,UAAkB;QAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAEF,QAAQ,2DAAG,IAAI,CAACA,QAAQ;gBAAA,MACpE,CAACA,QAAQ,IAAI,CAACE,UAAU;kBAAA;kBAAA;gBAAA;gBAAA,MACpB,IAAIC,KAAK,CAAC,oBAAoB,CAAC;cAAA;gBAAA;gBAAA,IAIhC,IAAI,CAACF,MAAM;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACS,IAAI,CAACG,SAAS,CAAe;kBAClDC,IAAI,wBAAiBH,UAAU,cAAIF,QAAQ,CAAE;kBAC7CM,MAAM,EAAE,KAAK;kBACbC,QAAQ,EAAE,OAAO;kBACjBV,MAAM,EAAE;oBACNW,QAAQ,EAAE;;iBAEb,CAAC;cAAA;gBAPIC,QAAQ;gBAAA,iCAQPA,QAAQ;cAAA;gBAAA;gBAAA,OAEQC,sBAAY,CAACC,kBAAkB,CAAe;kBACnEN,IAAI,wBAAiB,IAAI,CAACJ,MAAM,cAAIC,UAAU,cAAIF,QAAQ,CAAE;kBAC5DM,MAAM,EAAE,KAAK;kBACbC,QAAQ,EAAE;iBACX,CAAC;cAAA;gBAJIE,SAAQ;gBAAA,iCAKPA,SAAQ;cAAA;gBAAA;gBAAA;cAAA;gBAAA;gBAAA;gBAAA,iCAGV,IAAI;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEd;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,kFAaO,kBAAsBT,QAAgB,EAAEE,UAAkB,EAAEU,GAAW;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MACxE,CAACZ,QAAQ,IAAI,CAACE,UAAU,IAAI,CAACU,GAAG;kBAAA;kBAAA;gBAAA;gBAAA,MAC5B,IAAIT,KAAK,CAAC,oBAAoB,CAAC;cAAA;gBAAA;gBAAA,OAIX,IAAI,CAACU,gBAAgB,CAACX,UAAU,EAAEF,QAAQ,CAAC;cAAA;gBAAjEc,aAAa;gBAAA,MAGf,CAACA,aAAa,IAAI,CAACA,aAAa,CAACF,GAAG,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,6CAC5BV,UAAU,cAAIU,GAAG;cAAA;gBAAA,kCAGvBE,aAAa,CAACF,GAAG,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC1B;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OAcO,yBAAgBG,UAAkB;MACvC,IAAMC,eAAe,GAAGD,UAAU,CAACE,KAAK,CAACtB,mBAAmB,CAAC;MAC7D,IAAI,CAACqB,eAAe,EAAE;QACpB,OAAO,IAAI;;MAGb,IAAMd,UAAU,GAAGc,eAAe,CAAC,CAAC,CAAC;MACrC,IAAME,aAAa,GAAGF,eAAe,CAAC,CAAC,CAAC;MAExC,IAAID,UAAU,CAACI,QAAQ,CAAC,GAAG,CAAC,EAAE;QAC5B,kBAAiBC,IAAI,CAACC,KAAK,CAAWH,aAAa,CAAC;UAA5CI,IAAI,eAAJA,IAAI;QACZ,sBAAyBA,IAAI,CAAC,CAAC,CAAC;UAAzBV,GAAG;UAAKf,MAAM;QAErB,OAAO;UAAEK,UAAU,EAAVA,UAAU;UAAEU,GAAG,EAAHA,GAAG;UAAEf,MAAM,EAANA;QAAM,CAAE;;MAGpC,OAAO;QAAEK,UAAU,EAAVA,UAAU;QAAEU,GAAG,EAAEM;MAAa,CAAE;IAC3C;IAEA;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,oFAqBO,kBAAwBK,aAAuC;QAAA;QAAA;UAAA;YAAA;cAAA;gBAC5DvB,QAAQ,GAAiBuB,aAAa,CAAtCvB,QAAQ,EAAEe,UAAU,GAAKQ,aAAa,CAA5BR,UAAU;gBACpBb,UAAU,GAAkBa,UAAU,CAAtCb,UAAU,EAAEU,GAAG,GAAaG,UAAU,CAA1BH,GAAG,EAAEf,MAAM,GAAKkB,UAAU,CAArBlB,MAAM;gBAAA;gBAAA,OAIR,IAAI,CAAC2B,eAAe,CAACxB,QAAQ,EAAEE,UAAU,EAAEU,GAAG,CAAC;cAAA;gBAAtEa,cAAc;gBACd5B,MAAM,CAAC6B,OAAO,CAAC,UAACC,YAAY,EAAEC,KAAK,EAAI;kBACrC,IAAMC,SAAS,GAAG,IAAIC,MAAM,cAAOF,KAAK,GAAI,GAAG,CAAC;kBAChDH,cAAc,GAAGA,cAAc,CAACM,OAAO,CAACF,SAAS,EAAEF,YAAY,CAAC;gBAClE,CAAC,CAAC;gBAAC,kCAEIF,cAAc;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACtB;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,2FAYO,kBAA+BO,SAAiB;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAC/CC,MAAM,GAAGD,SAAS,CAACE,KAAK,CAACxC,mBAAmB,CAAC;gBAE7CyC,WAAW,GAAGF,MAAM,CACvBG,MAAM,CAAC,UAACtC,KAAK;kBAAA,OAAKJ,mBAAmB,CAAC2C,IAAI,CAACvC,KAAK,CAAC;gBAAA,EAAC,CAClDwC,GAAG,CAAC,UAACvB,UAAU;kBAAA,OAAK,MAAI,CAACwB,eAAe,CAACxB,UAAU,CAAC;gBAAA,EAAC;gBAAA,kCAEjDoB,WAAW;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACnB;MAAA;QAAA;MAAA;MAAA;IAAA;IAED;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA;MAAA,gFAkBO,kBAAoBH,SAAiB,EAAEQ,OAA+B;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBACnExC,QAAQ,GAAK,IAAI,CAAjBA,QAAQ,EAEhB;gBAAA,MACI,CAACgC,SAAS,IAAI,CAAChC,QAAQ;kBAAA;kBAAA;gBAAA;gBAAA,kCAClBgC,SAAS,IAAI,EAAE;cAAA;gBAAA,MAMpB,OAAOA,SAAS,KAAK,QAAQ,IAAI,CAACA,SAAS,CAACb,QAAQ,CAAC,GAAG,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,kCACpDa,SAAS;cAAA;gBAGZS,SAAS,GAAGT,SAAS,CAACE,KAAK,CAACxC,mBAAmB,CAAC;gBAEhDgD,mBAAmB,GAAGD,SAAS,CAACH,GAAG,CAAC,UAACxC,KAAK,EAAI;kBAClD,IAAM6C,YAAY,GAAG7C,KAAK,CAAC8C,UAAU,CAAC,GAAG,CAAC,IAAI9C,KAAK,CAAC+C,QAAQ,CAAC,GAAG,CAAC;kBACjE,IAAIF,YAAY,EAAE;oBAChB,IAAM5B,UAAU,GAAG,MAAI,CAACwB,eAAe,CAACzC,KAAK,CAAC;oBAC9C,IAAI,CAACiB,UAAU,EAAE;sBACf,OAAOjB,KAAK;;oBAGd,IAAQI,UAAU,GAAkBa,UAAU,CAAtCb,UAAU;sBAAEU,GAAG,GAAaG,UAAU,CAA1BH,GAAG;sBAAEf,MAAM,GAAKkB,UAAU,CAArBlB,MAAM;oBAE/B,OAAOA,MAAM,GACT,MAAI,CAACiD,iBAAiB,CAAC;sBAAE9C,QAAQ,EAARA,QAAQ;sBAAEe,UAAU,EAAVA;oBAAU,CAAE,CAAC,GAChD,MAAI,CAACS,eAAe,CAACxB,QAAQ,EAAEE,UAAU,EAAEU,GAAG,CAAC;mBACpD,MAAM;oBACL,OAAOd,KAAK;;gBAEhB,CAAC,CAAC;gBAAA;gBAAA,OAGIiD,OAAO,CAACC,GAAG,CAACN,mBAAmB,CAAC,CAACO,IAAI,CAAC,UAACC,cAAc,EAAI;kBAC7DC,YAAY,GAAGD,cAAc,CAACE,IAAI,CAAC,EAAE,CAAC;gBACxC,CAAC,CAAC;cAAA;gBAAA,kCAEKD,YAAY;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACpB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EAnOsBzC,sBAAqC;AAsO9D2C,kBAAezD,UAAU","names":["RE_SPLIT_EXPRESSION","RE_MATCH_EXPRESSION","Dictionary","params","token","region","language","runURL","dictionary","Error","doRequest","path","method","cacheTTL","fallback","response","TagoIOModule_1","doRequestAnonymous","key","getLanguagesData","languagesData","expression","splitExpression","match","keyWithParams","includes","Papa","parse","data","resolveParams","getValueFromKey","resolvedString","forEach","substitution","index","subRegexp","RegExp","replace","rawString","tokens","split","expressions","filter","test","map","parseExpression","options","tokenized","substitutedPromises","isExpression","startsWith","endsWith","resolveExpression","Promise","all","then","resolvedValues","resultString","join","exports"],"sources":["C:\\Users\\kaique\\Documents\\SGA\\widget\\project\\node_modules\\@tago-io\\sdk\\src\\modules\\Dictionary\\Dictionary.ts"],"sourcesContent":["import * as Papa from \"papaparse\";\r\n\r\nimport TagoIOModule from \"../../common/TagoIOModule\";\r\nimport {\r\n  IDictionaryModuleParams,\r\n  IParsedExpression,\r\n  IResolveExpressionParams,\r\n  IApplyToStringOptions,\r\n  IDictionaryModuleParamsAnonymous,\r\n} from \"./dictionary.types\";\r\nimport { LanguageData } from \"../Account/dictionaries.types\";\r\n\r\n// Regular expressions that are used for parsing the strings:\r\n// - SPLIT is used to split the string into normal words/phrases and expressions\r\n// - MATCH is used to extract the parts that compose an expression\r\nconst RE_SPLIT_EXPRESSION = /(#[A-Z0-9]+\\.[A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*#)/;\r\nconst RE_MATCH_EXPRESSION = /#([A-Z0-9]+)\\.([A-Z0-9_]+(?:,(?:[^,#\"]+|\\\"[^\\\"]+\\\")+)*)#/;\r\n\r\nclass Dictionary extends TagoIOModule<IDictionaryModuleParams> {\r\n  public language: string;\r\n  public runURL?: string;\r\n\r\n  constructor(params: IDictionaryModuleParams);\r\n  constructor(params: IDictionaryModuleParamsAnonymous);\r\n  constructor(params: any) {\r\n    super({ token: params?.token || \"unknown\", region: params?.region });\r\n    this.language = params?.language || \"en-US\";\r\n    this.runURL = params?.runURL;\r\n  }\r\n\r\n  /**\r\n   * Get the language data for a dictionary.\r\n   *\r\n   * @param language Language.\r\n   * @param dictionary ID or Slug.\r\n   * @param runURL URL for the Run to make anonymous request.\r\n   */\r\n  public async getLanguagesData(dictionary: string, language = this.language): Promise<LanguageData> {\r\n    if (!language || !dictionary) {\r\n      throw new Error(\"Missing parameters\");\r\n    }\r\n\r\n    try {\r\n      if (!this.runURL) {\r\n        const response = await this.doRequest<LanguageData>({\r\n          path: `/dictionary/${dictionary}/${language}`,\r\n          method: \"GET\",\r\n          cacheTTL: 3600000,\r\n          params: {\r\n            fallback: true,\r\n          },\r\n        });\r\n        return response;\r\n      } else {\r\n        const response = await TagoIOModule.doRequestAnonymous<LanguageData>({\r\n          path: `/dictionary/${this.runURL}/${dictionary}/${language}`,\r\n          method: \"GET\",\r\n          cacheTTL: 3600000,\r\n        });\r\n        return response;\r\n      }\r\n    } catch (e) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get value from a key in a specific dictionary for a language.\r\n   *\r\n   * @param language Name of the language (locale code).\r\n   * @param dictionary Name of the dictionary.\r\n   * @param key Name of the key.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.getValueFromKey(\"en-US\", \"TEST\", \"OK_BUTTON_LABEL\");\r\n   * ```\r\n   */\r\n  public async getValueFromKey(language: string, dictionary: string, key: string): Promise<string> {\r\n    if (!language || !dictionary || !key) {\r\n      throw new Error(\"Missing parameters\");\r\n    }\r\n\r\n    // Get the dictionary language data from the profile route or anonymous route (Run)\r\n    const languagesData = await this.getLanguagesData(dictionary, language);\r\n\r\n    // Return expression as is if the request fails or either dictionary/key do not exist\r\n    if (!languagesData || !languagesData[key]) {\r\n      return `#${dictionary}.${key}#`;\r\n    }\r\n\r\n    return languagesData[key];\r\n  }\r\n\r\n  /**\r\n   * Parse an expression and extract the names of the dictionary, the key, and\r\n   * any arguments that are passed in the expression.\r\n   *\r\n   * Returns `null` if the value passed is not parseable by the RegEx.\r\n   *\r\n   * @param expression String expression.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.parseExpression(\"#TAGORUN.WELCOME_TEXT,Hello\");\r\n   * ```\r\n   */\r\n  public parseExpression(expression: string): IParsedExpression {\r\n    const splitExpression = expression.match(RE_MATCH_EXPRESSION);\r\n    if (!splitExpression) {\r\n      return null;\r\n    }\r\n\r\n    const dictionary = splitExpression[1];\r\n    const keyWithParams = splitExpression[2];\r\n\r\n    if (expression.includes(\",\")) {\r\n      const { data } = Papa.parse<string[]>(keyWithParams);\r\n      const [key, ...params] = data[0];\r\n\r\n      return { dictionary, key, params };\r\n    }\r\n\r\n    return { dictionary, key: keyWithParams };\r\n  }\r\n\r\n  /**\r\n   * Resolve an expression in a language, replacing the parameters in the\r\n   * dictionary value with the arguments passed in the expression.\r\n   *\r\n   * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const value = dictionary.resolveExpression({\r\n   *   language: \"en-US\",\r\n   *   expression: {\r\n   *     dictionary: \"TEST\",\r\n   *     key: \"SOME_KEY\",\r\n   *     params: [\r\n   *       \"first parameter\",\r\n   *     ],\r\n   *   },\r\n   * });\r\n   * ```\r\n   */\r\n  public async resolveExpression(resolveParams: IResolveExpressionParams): Promise<string> {\r\n    const { language, expression } = resolveParams;\r\n    const { dictionary, key, params } = expression;\r\n    let resolvedString: string;\r\n\r\n    // Get the dictionary value string for the expression to substitute the arguments into it\r\n    resolvedString = await this.getValueFromKey(language, dictionary, key);\r\n    params.forEach((substitution, index) => {\r\n      const subRegexp = new RegExp(`\\\\$${index}`, \"g\");\r\n      resolvedString = resolvedString.replace(subRegexp, substitution);\r\n    });\r\n\r\n    return resolvedString;\r\n  }\r\n\r\n  /**\r\n   * Get all (and only) the expressions in a string and their parameters if applicable,\r\n   * ignoring normal words and phrases.\r\n   *\r\n   * @param rawString String with words and/or expressions.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const expressions = dictionary.getExpressionsFromString(\"Words are ignored #TEST.DICT_KEY#\");\r\n   * ```\r\n   */\r\n  public async getExpressionsFromString(rawString: string): Promise<IParsedExpression[]> {\r\n    const tokens = rawString.split(RE_SPLIT_EXPRESSION);\r\n\r\n    const expressions = tokens\r\n      .filter((token) => RE_SPLIT_EXPRESSION.test(token))\r\n      .map((expression) => this.parseExpression(expression));\r\n\r\n    return expressions;\r\n  }\r\n\r\n  /**\r\n   * Apply the dictionary over a string, parsing the expressions in the string and\r\n   * replacing them with the values found for the respective keys inside the dictionary\r\n   * for a language.\r\n   *\r\n   * Always returns a string. Return the translated string if there are dictionary expressions,\r\n   * the raw string with no changes if there are no expressions, and an empty string if `rawString`\r\n   * is undefined.\r\n   *\r\n   * @param rawString String with words and/or expressions.\r\n   * @param options Object containing options for the dictionary, including the language.\r\n   *\r\n   * @example\r\n   * ```\r\n   * const dictionary = new Dictionary({ language: \"en-US\", token: \"my-token\" });\r\n   * const result = dictionary.applyToString(\"Words are ignored #TEST.DICT_KEY#\");\r\n   * ```\r\n   */\r\n  public async applyToString(rawString: string, options?: IApplyToStringOptions): Promise<string> {\r\n    const { language } = this;\r\n\r\n    // Handling undefined strings is not this function's job\r\n    if (!rawString || !language) {\r\n      return rawString || \"\";\r\n    }\r\n\r\n    // Bail early if there are no variables in the string or if the value passed\r\n    // is not a string, which can happen when not using TypeScript or passing the\r\n    // instance to a function without the type\r\n    if (typeof rawString !== \"string\" || !rawString.includes(\"#\")) {\r\n      return rawString;\r\n    }\r\n\r\n    const tokenized = rawString.split(RE_SPLIT_EXPRESSION);\r\n\r\n    const substitutedPromises = tokenized.map((token) => {\r\n      const isExpression = token.startsWith(\"#\") && token.endsWith(\"#\");\r\n      if (isExpression) {\r\n        const expression = this.parseExpression(token);\r\n        if (!expression) {\r\n          return token;\r\n        }\r\n\r\n        const { dictionary, key, params } = expression;\r\n\r\n        return params\r\n          ? this.resolveExpression({ language, expression })\r\n          : this.getValueFromKey(language, dictionary, key);\r\n      } else {\r\n        return token;\r\n      }\r\n    });\r\n\r\n    let resultString: string;\r\n    await Promise.all(substitutedPromises).then((resolvedValues) => {\r\n      resultString = resolvedValues.join(\"\");\r\n    });\r\n\r\n    return resultString;\r\n  }\r\n}\r\n\r\nexport default Dictionary;\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}