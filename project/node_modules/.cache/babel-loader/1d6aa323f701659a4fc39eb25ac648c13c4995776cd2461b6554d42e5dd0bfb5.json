{"ast":null,"code":"const axios = require('axios');\nexport class location_apis {\n  constructor() {\n    this.prepare_mac_parameterers_for_requisition = (wifi_fields, esn) => {\n      //private method\n      let wifi_parameters_list = new Array();\n      if (wifi_fields === undefined) {\n        return;\n      } else {\n        wifi_fields.forEach(key => {\n          if (!esn.metadata[key]) {\n            //if there isn´t nothing field with the specific wifi name, will retun the function.\n            return;\n          }\n          let wifi_fields_array = esn.metadata[key].split(\",\");\n          wifi_parameters_list.push({\n            macAddress: wifi_fields_array[0],\n            signalStrength: wifi_fields_array[1],\n            signalToNoiseRatio: 0\n          });\n        });\n      }\n      return wifi_parameters_list;\n    };\n    this.prepare_lbs_parameters_for_requesition = (keyTag, esn, dataType) => {\n      if (keyTag === undefined) {\n        return;\n      }\n      let lbsList = new Array();\n      keyTag.forEach(key => {\n        if (!esn.metadata[key]) {\n          return;\n        } // if there isn´t nothing field with the specific lbs, will retun the function.\n\n        let arrayFieldsLbs = esn.metadata[key].split(',');\n        if (arrayFieldsLbs.length < 3) {\n          return;\n        }\n        if (arrayFieldsLbs[4] === \"FFFF\" || arrayFieldsLbs[7] === \"0000\") {\n          return;\n        }\n        ;\n        if (arrayFieldsLbs.length > 10) {\n          if (dataType === \"lte\") {\n            lbsList.push({\n              cell: arrayFieldsLbs[0],\n              earfcn: arrayFieldsLbs[1],\n              pci: arrayFieldsLbs[2],\n              rsrp: arrayFieldsLbs[3],\n              rssi: arrayFieldsLbs[4],\n              rsrq: arrayFieldsLbs[5],\n              sinr: arrayFieldsLbs[6],\n              lac: arrayFieldsLbs[7],\n              cellid: arrayFieldsLbs[8],\n              mcc: arrayFieldsLbs[9],\n              mnc: arrayFieldsLbs[10],\n              txPower: arrayFieldsLbs[11]\n            });\n          } else {\n            lbsList.push({\n              cell: arrayFieldsLbs[0],\n              bcch: arrayFieldsLbs[1],\n              rxl: arrayFieldsLbs[2],\n              rxq: arrayFieldsLbs[3],\n              mcc: arrayFieldsLbs[4],\n              mnc: arrayFieldsLbs[5],\n              bsic: arrayFieldsLbs[6],\n              cellid: arrayFieldsLbs[7],\n              rla: arrayFieldsLbs[8],\n              txp: arrayFieldsLbs[9],\n              lac: arrayFieldsLbs[10],\n              ta: arrayFieldsLbs[11]\n            });\n          }\n        } else {\n          if (dataType === \"lte\") {\n            lbsList.push({\n              cell: arrayFieldsLbs[0],\n              earfcn: arrayFieldsLbs[1],\n              pci: arrayFieldsLbs[2],\n              rsrp: arrayFieldsLbs[3],\n              rssi: arrayFieldsLbs[4],\n              rsrq: arrayFieldsLbs[5],\n              sinr: arrayFieldsLbs[6]\n            });\n          } else {\n            lbsList.push({\n              cell: arrayFieldsLbs[0],\n              bcch: arrayFieldsLbs[1],\n              rxl: arrayFieldsLbs[2],\n              bsic: arrayFieldsLbs[3],\n              cellid: arrayFieldsLbs[4],\n              mcc: arrayFieldsLbs[5],\n              mnc: arrayFieldsLbs[6],\n              lac: arrayFieldsLbs[7]\n            });\n          }\n        }\n      });\n      return lbsList;\n    };\n    this.get_address_through_coordinates = async (latitude, longitude) => {\n      //public method\n      const request = await axios.get(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}`);\n      if (request.data.address !== undefined) {\n        let address = request.data.address;\n        return address.quarter === undefined ? `${address.road} - ${address.suburb} - ${address.state} - ${address.city} - ${address.postcode}` : `${address.road} - ${address.quarter} - ${address.state} - ${address.city} - ${address.postcode}`;\n      } else {\n        return {\n          address: \"no data available\"\n        };\n      }\n    };\n    this.get_coordinates_through_mac_datas = async (wifi_fields, esn) => {\n      let list = this.prepare_mac_parameterers_for_requisition(wifi_fields, esn);\n      try {\n        /* if the mode that i sent to a function is the same the wifi, i want that the function made a macAddress requisition */\n        const result = await axios({\n          method: \"POST\",\n          url: \"https://www.googleapis.com/geolocation/v1/geolocate\",\n          params: {\n            key: \"AIzaSyDq2lk5DBMUg2ymbDimMunBbvQwk-4MeLg\"\n          },\n          data: {\n            homeMobileCountryCode: 0,\n            homeMobileNetworkCode: 0,\n            radioType: \"gsm\",\n            carrier: \"Vodafone\",\n            considerIp: false,\n            wifiAccessPoints: list\n          }\n        });\n        if (!result) {\n          return {\n            lat: 0,\n            lng: 0\n          };\n        }\n        ;\n        return result.data.location;\n      } catch (e) {\n        return {\n          lat: 0,\n          lng: 0\n        };\n      }\n    };\n    this.get_coordinates_through_lbs_datas = async (lbs_fields, esn, data_type) => {\n      console.log();\n      try {\n        let list = this.prepare_lbs_parameters_for_requesition(lbs_fields, esn, data_type);\n        let cellTowers = list.map(lbs => {\n          /* I create a array with several objects, this array will be used how parameter in the google API  */\n          return {\n            cellId: data_type === \"lte\" ? parseInt(lbs.cellid) : parseInt(lbs.cellid),\n            locationAreaCode: data_type === \"lte\" ? parseInt(lbs.lac) : parseInt(lbs.lac),\n            mobileCountryCode: parseInt(lbs.mcc),\n            mobileNetworkCode: parseInt(lbs.mnc)\n          };\n        });\n        const lbs0 = list.find(x => x.cell === \"LBS0\");\n        if (!lbs0) {\n          return {\n            lat: 0,\n            lng: 0\n          };\n        }\n        ;\n\n        /*  Google api will return geography coordinates accordingly with the lbs Datas returned of const cellTowers(objects array) */\n        const result = await axios({\n          method: \"POST\",\n          url: \"https://www.googleapis.com/geolocation/v1/geolocate\",\n          params: {\n            key: \"AIzaSyDq2lk5DBMUg2ymbDimMunBbvQwk-4MeLg\"\n          },\n          data: {\n            homeMobileCountryCode: parseInt(lbs0.mcc),\n            homeMobileNetworkCode: parseInt(lbs0.mnc),\n            radioType: data_type === \"lte\" ? \"LTE\" : \"gsm\",\n            //define o tipo de dados que a minha api vai receber GSM | LTE\n            carrier: \"Vodafone\",\n            considerIp: false,\n            cellTowers: data_type === \"lte\" ? [cellTowers[0]] : cellTowers\n          }\n        }).catch(err => console.log());\n        if (!result) {\n          return {\n            lat: 0,\n            lng: 0\n          };\n        }\n        ;\n        return result.data.location;\n      } catch (e) {\n        return {\n          lat: 0,\n          lng: 0\n        };\n      }\n    };\n  }\n}","map":{"version":3,"names":["axios","require","location_apis","prepare_mac_parameterers_for_requisition","wifi_fields","esn","wifi_parameters_list","Array","undefined","forEach","key","metadata","wifi_fields_array","split","push","macAddress","signalStrength","signalToNoiseRatio","prepare_lbs_parameters_for_requesition","keyTag","dataType","lbsList","arrayFieldsLbs","length","cell","earfcn","pci","rsrp","rssi","rsrq","sinr","lac","cellid","mcc","mnc","txPower","bcch","rxl","rxq","bsic","rla","txp","ta","get_address_through_coordinates","latitude","longitude","request","get","data","address","quarter","road","suburb","state","city","postcode","get_coordinates_through_mac_datas","list","result","method","url","params","homeMobileCountryCode","homeMobileNetworkCode","radioType","carrier","considerIp","wifiAccessPoints","lat","lng","location","e","get_coordinates_through_lbs_datas","lbs_fields","data_type","console","log","cellTowers","map","lbs","cellId","parseInt","locationAreaCode","mobileCountryCode","mobileNetworkCode","lbs0","find","x","catch","err"],"sources":["C:/Users/yudji/OneDrive/Documentos/SGA/WIDGETS/custom_widgets/project/src/classes/location/location.js"],"sourcesContent":["const axios = require('axios');\r\n\r\n\r\nexport class location_apis {\r\n\r\n\r\n     prepare_mac_parameterers_for_requisition = (wifi_fields, esn) => {//private method\r\n            let wifi_parameters_list = new Array();\r\n    \r\n            if(wifi_fields === undefined){\r\n                return; \r\n            }else{\r\n                wifi_fields.forEach(key => {\r\n                if(!esn.metadata[key]){//if there isn´t nothing field with the specific wifi name, will retun the function.\r\n                  return\r\n                }\r\n            \r\n                let wifi_fields_array = esn.metadata[key].split(\",\");\r\n                wifi_parameters_list.push({\r\n                  macAddress: wifi_fields_array[0],\r\n                  signalStrength: wifi_fields_array[1],\r\n                  signalToNoiseRatio: 0,\r\n                })\r\n            \r\n              });\r\n            } \r\n            \r\n        return wifi_parameters_list;\r\n     }\r\n    \r\n\r\n\r\n\r\n\r\n      prepare_lbs_parameters_for_requesition = (keyTag,esn,dataType) => {\r\n        if(keyTag === undefined){ return; }\r\n\r\n        let lbsList = new Array();   \r\n          \r\n              keyTag.forEach(key => {\r\n      \r\n                  if(!esn.metadata[key]){ return; }// if there isn´t nothing field with the specific lbs, will retun the function.\r\n              \r\n                  let arrayFieldsLbs = (esn.metadata[key]).split(',');\r\n                  if (arrayFieldsLbs.length < 3) { return; }\r\n                  if (arrayFieldsLbs[4] === \"FFFF\" || arrayFieldsLbs[7] === \"0000\") { return; };\r\n      \r\n                  if (arrayFieldsLbs.length > 10) {\r\n\r\n                    if(dataType === \"lte\"){\r\n                        lbsList.push({\r\n                            cell: arrayFieldsLbs[0],\r\n                            earfcn: arrayFieldsLbs[1],\r\n                            pci: arrayFieldsLbs[2],\r\n                            rsrp: arrayFieldsLbs[3],\r\n                            rssi: arrayFieldsLbs[4],\r\n                            rsrq: arrayFieldsLbs[5],\r\n                            sinr: arrayFieldsLbs[6],\r\n                            lac: arrayFieldsLbs[7],\r\n                            cellid:arrayFieldsLbs[8],\r\n                            mcc:arrayFieldsLbs[9],\r\n                            mnc:arrayFieldsLbs[10],\r\n                            txPower:arrayFieldsLbs[11]\r\n                        });\r\n                        }else{\r\n                            lbsList.push({\r\n                                cell: arrayFieldsLbs[0],\r\n                                bcch: arrayFieldsLbs[1],\r\n                                rxl: arrayFieldsLbs[2],\r\n                                rxq: arrayFieldsLbs[3],\r\n                                mcc: arrayFieldsLbs[4],\r\n                                mnc: arrayFieldsLbs[5],\r\n                                bsic: arrayFieldsLbs[6],\r\n                                cellid: arrayFieldsLbs[7],\r\n                                rla: arrayFieldsLbs[8],\r\n                                txp: arrayFieldsLbs[9],\r\n                                lac: arrayFieldsLbs[10],\r\n                                ta: arrayFieldsLbs[11],\r\n                            });\r\n                        }\r\n\r\n                  }else {\r\n                    if(dataType === \"lte\"){\r\n                        lbsList.push({\r\n                      cell: arrayFieldsLbs[0],\r\n                      earfcn: arrayFieldsLbs[1],\r\n                      pci: arrayFieldsLbs[2],\r\n                      rsrp: arrayFieldsLbs[3],\r\n                      rssi: arrayFieldsLbs[4],\r\n                      rsrq: arrayFieldsLbs[5],\r\n                      sinr: arrayFieldsLbs[6]\r\n                      });  \r\n                    \r\n                    }else{\r\n                        lbsList.push({\r\n                            cell: arrayFieldsLbs[0],\r\n                            bcch: arrayFieldsLbs[1],\r\n                            rxl: arrayFieldsLbs[2],\r\n                            bsic: arrayFieldsLbs[3],\r\n                            cellid: arrayFieldsLbs[4],\r\n                            mcc: arrayFieldsLbs[5],\r\n                            mnc: arrayFieldsLbs[6],\r\n                            lac: arrayFieldsLbs[7],\r\n                            });\r\n                    }\r\n\r\n\r\n                  }\r\n        \r\n              });\r\n      \r\n\r\n            \r\n            return lbsList;\r\n      \r\n      }//end of function parseToObjectLBS\r\n     \r\n     \r\n     \r\n     \r\n     \r\n     get_address_through_coordinates = async(latitude, longitude) =>{//public method\r\n        const request = await axios.get(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}`);\r\n        \r\n        if(request.data.address !== undefined){\r\n          let address = request.data.address;\r\n\r\n          return address.quarter === undefined\r\n                              ? `${address.road} - ${address.suburb} - ${address.state} - ${address.city} - ${address.postcode}`\r\n                              : `${address.road} - ${address.quarter} - ${address.state} - ${address.city} - ${address.postcode}`; \r\n        }else{\r\n         return {address: \"no data available\"};\r\n        }\r\n        \r\n      }\r\n\r\n\r\n\r\n\r\n\r\n       get_coordinates_through_mac_datas = async(wifi_fields, esn) =>{\r\n          \r\n         let list = this.prepare_mac_parameterers_for_requisition(wifi_fields, esn);\r\n        \r\n            try{\r\n                    /* if the mode that i sent to a function is the same the wifi, i want that the function made a macAddress requisition */\r\n                    const result = await axios({\r\n                        method: \"POST\",\r\n                        url: \"https://www.googleapis.com/geolocation/v1/geolocate\",\r\n                        params: {\r\n                          key: \"AIzaSyDq2lk5DBMUg2ymbDimMunBbvQwk-4MeLg\",\r\n                        },\r\n                        data: {\r\n                          homeMobileCountryCode: 0,\r\n                          homeMobileNetworkCode: 0,\r\n                          radioType: \"gsm\",\r\n                          carrier: \"Vodafone\",\r\n                          considerIp: false,\r\n                          wifiAccessPoints: list\r\n                        },\r\n                    })\r\n        \r\n\r\n                    if (!result) { return {lat:0, lng:0} };\r\n                    return result.data.location;\r\n\r\n            }catch(e){ return {lat:0, lng:0} }\r\n   \r\n     } \r\n\r\n\r\n\r\n\r\n\r\n     get_coordinates_through_lbs_datas = async(lbs_fields, esn, data_type) =>{console.log()\r\n         try{\r\n                 let list = this.prepare_lbs_parameters_for_requesition(lbs_fields, esn, data_type);\r\n             \r\n                 let cellTowers = list.map((lbs) => {/* I create a array with several objects, this array will be used how parameter in the google API  */\r\n                      return {\r\n                         cellId: data_type === \"lte\" ?  parseInt(lbs.cellid) :parseInt(lbs.cellid),\r\n                         locationAreaCode :data_type === \"lte\" ?parseInt(lbs.lac) :parseInt(lbs.lac),\r\n                         mobileCountryCode: parseInt(lbs.mcc),\r\n                         mobileNetworkCode: parseInt(lbs.mnc),\r\n                        };\r\n                  });\r\n          \r\n                 \r\n                  \r\n                 const lbs0 = list.find((x) => x.cell === \"LBS0\");\r\n                 if(!lbs0){ return {lat:0, lng:0} };\r\n          \r\n            \r\n                    \r\n            /*  Google api will return geography coordinates accordingly with the lbs Datas returned of const cellTowers(objects array) */\r\n                const result = await axios({\r\n                    method: \"POST\",\r\n                    url: \"https://www.googleapis.com/geolocation/v1/geolocate\",\r\n                    params: {\r\n                      key: \"AIzaSyDq2lk5DBMUg2ymbDimMunBbvQwk-4MeLg\",\r\n                    },\r\n                    data: {\r\n                       homeMobileCountryCode: parseInt(lbs0.mcc),\r\n                       homeMobileNetworkCode: parseInt(lbs0.mnc),\r\n                       radioType: data_type === \"lte\" ?\"LTE\" :\"gsm\",//define o tipo de dados que a minha api vai receber GSM | LTE\r\n                       carrier: \"Vodafone\",\r\n                       considerIp: false,\r\n                       cellTowers: data_type === \"lte\" ? [cellTowers[0]] :cellTowers\r\n                      }\r\n                    }).catch((err) => console.log())\r\n                            \r\n                          \r\n                    if(!result) { return {lat:0, lng:0} };\r\n                    return result.data.location;\r\n                    \r\n            }catch(e){ return {lat:0, lng:0}; }\r\n           \r\n        \r\n   \r\n     }\r\n\r\n\r\n}\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}