{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/kaique/Documents/SGA/widget/project/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar form_data_1 = __importDefault(require(\"form-data\"));\nvar sleep_1 = __importDefault(require(\"../../common/sleep\"));\nvar TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\nvar dateParser_1 = __importDefault(require(\"../Utils/dateParser\"));\nvar Files = /*#__PURE__*/function (_TagoIOModule_1$defau) {\n  _inherits(Files, _TagoIOModule_1$defau);\n  var _super = _createSuper(Files);\n  function Files() {\n    _classCallCheck(this, Files);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Files, [{\n    key: \"list\",\n    value:\n    /**\r\n     * list of files in account\r\n     * @param queryObj Object with path, pagination and quantity\r\n     */\n    function () {\n      var _list = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(queryObj) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.doRequest({\n                  path: \"/files\",\n                  method: \"GET\",\n                  params: {\n                    path: (queryObj === null || queryObj === void 0 ? void 0 : queryObj.path) || \"/\",\n                    pagination_token: queryObj === null || queryObj === void 0 ? void 0 : queryObj.paginationToken,\n                    qty: (queryObj === null || queryObj === void 0 ? void 0 : queryObj.quantity) || 300\n                  }\n                });\n              case 2:\n                result = _context.sent;\n                result.files = result === null || result === void 0 ? void 0 : result.files.map(function (data) {\n                  return (0, dateParser_1.default)(data, [\"last_modified\"]);\n                });\n                return _context.abrupt(\"return\", result);\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function list(_x) {\n        return _list.apply(this, arguments);\n      }\n      return list;\n    }()\n    /**\r\n     * Upload an array of files(Base64) to TagoIO\r\n     * The filename parameter is also full path\r\n     * @param fileList Array of files data to be uploaded\r\n     * @example\r\n     * ```json\r\n     * fileList: [\r\n     *   {\r\n     *     filename: \"/myfiles/myfile.ext\",\r\n     *     file: \"StringWithBase64\"\r\n     *   }\r\n     * ]\r\n     * ```\r\n     */\n  }, {\n    key: \"uploadBase64\",\n    value: function () {\n      var _uploadBase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fileList) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.doRequest({\n                  path: \"/files\",\n                  method: \"POST\",\n                  body: fileList\n                });\n              case 2:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function uploadBase64(_x2) {\n        return _uploadBase.apply(this, arguments);\n      }\n      return uploadBase64;\n    }()\n    /**\r\n     * Move/Rename Files\r\n     * @param fileList Array move actions to be made\r\n     * @example\r\n     * ```json\r\n     * fileList: [\r\n     *   {\r\n     *     from: \"/myfiles/myOldName.ext\",\r\n     *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n     *   }\r\n     * ]\r\n     * ```\r\n     */\n  }, {\n    key: \"move\",\n    value: function () {\n      var _move = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(fileList) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.doRequest({\n                  path: \"/files\",\n                  method: \"PUT\",\n                  body: fileList\n                });\n              case 2:\n                result = _context3.sent;\n                return _context3.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function move(_x3) {\n        return _move.apply(this, arguments);\n      }\n      return move;\n    }()\n    /**\r\n     * Copy Files\r\n     * @param fileList Array of copy actions to be made\r\n     * @example\r\n     * ```json\r\n     * fileList: [\r\n     *   {\r\n     *     from: \"/myfiles/myOldName.ext\",\r\n     *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n     *   }\r\n     * ]\r\n     * ```\r\n     */\n  }, {\n    key: \"copy\",\n    value: function () {\n      var _copy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(fileList) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.doRequest({\n                  path: \"/files/copy\",\n                  method: \"PUT\",\n                  body: fileList\n                });\n              case 2:\n                result = _context4.sent;\n                return _context4.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function copy(_x4) {\n        return _copy.apply(this, arguments);\n      }\n      return copy;\n    }()\n    /**\r\n     * Delete Folder or Files\r\n     * @param files An array of files or folders to be deleted\r\n     */\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(files) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.doRequest({\n                  path: \"/files\",\n                  method: \"DELETE\",\n                  body: files\n                });\n              case 2:\n                result = _context5.sent;\n                return _context5.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function _delete(_x5) {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n    /**\r\n     * Check if file is private or public\r\n     * @param file Path of file\r\n     */\n  }, {\n    key: \"checkPermission\",\n    value: function () {\n      var _checkPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(file) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.doRequest({\n                  path: \"/files/permission\",\n                  method: \"GET\",\n                  params: {\n                    file: file\n                  }\n                });\n              case 2:\n                result = _context6.sent;\n                return _context6.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function checkPermission(_x6) {\n        return _checkPermission.apply(this, arguments);\n      }\n      return checkPermission;\n    }()\n    /**\r\n     * Change visibility from files\r\n     * @param filesVisibility An Array with files and their visibility to be setted\r\n     */\n  }, {\n    key: \"changePermission\",\n    value: function () {\n      var _changePermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(filesVisibility) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.doRequest({\n                  path: \"/files/permission\",\n                  method: \"PUT\",\n                  body: filesVisibility\n                });\n              case 2:\n                result = _context7.sent;\n                return _context7.abrupt(\"return\", result);\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function changePermission(_x7) {\n        return _changePermission.apply(this, arguments);\n      }\n      return changePermission;\n    }()\n  }, {\n    key: \"getPathFromUrl\",\n    value: function () {\n      var _getPathFromUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url) {\n        var tagoURL;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                tagoURL = url.indexOf(\".tago.io/file/\");\n                if (!(tagoURL === -1)) {\n                  _context8.next = 3;\n                  break;\n                }\n                return _context8.abrupt(\"return\", Promise.reject(\"\".concat(url, \" is not a TagoIO files url\")));\n              case 3:\n                return _context8.abrupt(\"return\", url.slice(tagoURL + 8, url.length));\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n      function getPathFromUrl(_x8) {\n        return _getPathFromUrl.apply(this, arguments);\n      }\n      return getPathFromUrl;\n    }()\n    /**\r\n     * Get a file url with authenticate token valid for 120 seconds\r\n     * @param url Full TagoIO File url\r\n     */\n  }, {\n    key: \"getFileURLSigned\",\n    value: function () {\n      var _getFileURLSigned = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(url) {\n        var path, result;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.getPathFromUrl(url);\n              case 2:\n                path = _context9.sent;\n                _context9.next = 5;\n                return this.doRequest({\n                  path: path,\n                  method: \"GET\",\n                  params: {\n                    noRedirect: true\n                  }\n                });\n              case 5:\n                result = _context9.sent;\n                return _context9.abrupt(\"return\", result);\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function getFileURLSigned(_x9) {\n        return _getFileURLSigned.apply(this, arguments);\n      }\n      return getFileURLSigned;\n    }()\n    /**\r\n     * Get file md5 with authenticate token for privates files\r\n     * @param url Full TagoIO File url\r\n     */\n  }, {\n    key: \"getFileMD5\",\n    value: function () {\n      var _getFileMD = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(url) {\n        var path, result;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.getPathFromUrl(url);\n              case 2:\n                path = _context10.sent;\n                _context10.next = 5;\n                return this.doRequest({\n                  path: path,\n                  method: \"GET\",\n                  params: {\n                    md5: true,\n                    noRedirect: true\n                  }\n                });\n              case 5:\n                result = _context10.sent;\n                return _context10.abrupt(\"return\", result);\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n      function getFileMD5(_x10) {\n        return _getFileMD.apply(this, arguments);\n      }\n      return getFileMD5;\n    }()\n    /**\r\n     * Creates a multipart upload instance\r\n     * @param filename the path + filename for the file\r\n     * @param options the upload options for this file\r\n     */\n  }, {\n    key: \"createMultipartUpload\",\n    value: function () {\n      var _createMultipartUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(filename, options) {\n        var _ref, dashboard, widget, fieldId, isPublic, contentType, path, result;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _ref = options || {}, dashboard = _ref.dashboard, widget = _ref.widget, fieldId = _ref.fieldId, isPublic = _ref.isPublic, contentType = _ref.contentType;\n                path = dashboard && widget && fieldId ? \"/data/files/\".concat(dashboard, \"/\").concat(widget) : \"/files\";\n                _context11.next = 4;\n                return this.doRequest({\n                  path: path,\n                  method: \"POST\",\n                  body: _objectSpread({\n                    multipart_action: \"start\",\n                    filename: filename,\n                    public: options === null || options === void 0 ? void 0 : options.isPublic,\n                    contentType: contentType\n                  }, fieldId && {\n                    field_id: fieldId\n                  })\n                });\n              case 4:\n                result = _context11.sent;\n                return _context11.abrupt(\"return\", result);\n              case 6:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n      function createMultipartUpload(_x11, _x12) {\n        return _createMultipartUpload.apply(this, arguments);\n      }\n      return createMultipartUpload;\n    }()\n    /**\r\n     * Uploads a single part to TagoIO\r\n     * @param filename the path + filename for the file\r\n     * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n     * @param partNumber the sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n     * @param blob the portion of the file to be uploaded\r\n     * @param options the upload options for this file\r\n     */\n  }, {\n    key: \"_uploadPart\",\n    value: function () {\n      var _uploadPart2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(filename, uploadID, partNumber, blob, options) {\n        var _ref2, fieldId, path, form, headers, result;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _ref2 = options || {}, fieldId = _ref2.fieldId;\n                path = options !== null && options !== void 0 && options.dashboard && options !== null && options !== void 0 && options.widget ? \"/data/files/\".concat(options.dashboard, \"/\").concat(options.widget) : \"/files\";\n                form = new form_data_1.default();\n                form.append(\"filename\", filename);\n                form.append(\"upload_id\", uploadID);\n                form.append(\"part\", String(partNumber));\n                form.append(\"file\", blob, filename);\n                form.append(\"multipart_action\", \"upload\");\n                if (fieldId) {\n                  form.append(\"field_id\", fieldId);\n                }\n                headers = {\n                  \"Content-Type\": \"multipart/form-data\"\n                };\n                if (form.getHeaders) {\n                  headers = form.getHeaders();\n                }\n                _context12.next = 13;\n                return this.doRequest({\n                  path: path,\n                  method: \"POST\",\n                  body: form,\n                  maxContentLength: Infinity,\n                  headers: headers\n                });\n              case 13:\n                result = _context12.sent;\n                return _context12.abrupt(\"return\", {\n                  ETag: result.ETag,\n                  PartNumber: partNumber\n                });\n              case 15:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n      function _uploadPart(_x13, _x14, _x15, _x16, _x17) {\n        return _uploadPart2.apply(this, arguments);\n      }\n      return _uploadPart;\n    }()\n    /**\r\n     * Adds an upload to the queue.\r\n     * It will try to upload for 'opts.maxTriesForEachChunk' and fail\r\n     * if it couldn't upload after those many tries.\r\n     * @param filename the path + filename for the file\r\n     * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n     * @param partNumberthe sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n     * @param blob the portion of the file to be uploaded\r\n     * @param options see the uploadFile function\r\n     */\n  }, {\n    key: \"_addToQueue\",\n    value: function () {\n      var _addToQueue2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(filename, uploadID, partNumber, blob, options) {\n        var maxTries, timeout, tries, result;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                maxTries = (options === null || options === void 0 ? void 0 : options.maxTriesForEachChunk) || 5;\n                timeout = (options === null || options === void 0 ? void 0 : options.timeoutForEachFailedChunk) || 2000;\n                tries = 0;\n              case 3:\n                if (!(tries < maxTries)) {\n                  _context13.next = 22;\n                  break;\n                }\n                _context13.prev = 4;\n                _context13.next = 7;\n                return this._uploadPart(filename, uploadID, partNumber, blob, options);\n              case 7:\n                result = _context13.sent;\n                return _context13.abrupt(\"return\", result);\n              case 11:\n                _context13.prev = 11;\n                _context13.t0 = _context13[\"catch\"](4);\n                if (!isLimitError(_context13.t0)) {\n                  _context13.next = 15;\n                  break;\n                }\n                throw _context13.t0.message;\n              case 15:\n                _context13.next = 17;\n                return (0, sleep_1.default)(timeout);\n              case 17:\n                tries += 1;\n                if (!(tries >= maxTries)) {\n                  _context13.next = 20;\n                  break;\n                }\n                throw new Error(\"Could not upload part number \".concat(partNumber, \": \").concat(_context13.t0.message));\n              case 20:\n                _context13.next = 3;\n                break;\n              case 22:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[4, 11]]);\n      }));\n      function _addToQueue(_x18, _x19, _x20, _x21, _x22) {\n        return _addToQueue2.apply(this, arguments);\n      }\n      return _addToQueue;\n    }()\n    /**\r\n     * Finishes a multipart upload instance\r\n     * @param filename the path + filename for the file\r\n     * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n     * @param parts all the parts uploaded to the file\r\n     * @param options the upload options for this file\r\n     */\n  }, {\n    key: \"_completeMultipartUpload\",\n    value: function () {\n      var _completeMultipartUpload2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(filename, uploadID, parts, options) {\n        var _ref3, fieldId, path, partsOrdered, headers, result;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _ref3 = options || {}, fieldId = _ref3.fieldId;\n                path = options !== null && options !== void 0 && options.dashboard && options !== null && options !== void 0 && options.widget ? \"/data/files/\".concat(options.dashboard, \"/\").concat(options.widget) : \"/files\";\n                partsOrdered = parts.sort(function (a, b) {\n                  return a.PartNumber - b.PartNumber;\n                });\n                headers = {\n                  \"Content-Type\": \"multipart/form-data\"\n                };\n                _context14.next = 6;\n                return this.doRequest({\n                  path: path,\n                  method: \"POST\",\n                  body: _objectSpread({\n                    multipart_action: \"end\",\n                    upload_id: uploadID,\n                    filename: filename,\n                    parts: partsOrdered\n                  }, fieldId && {\n                    field_id: fieldId\n                  })\n                });\n              case 6:\n                result = _context14.sent;\n                return _context14.abrupt(\"return\", result);\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n      function _completeMultipartUpload(_x23, _x24, _x25, _x26) {\n        return _completeMultipartUpload2.apply(this, arguments);\n      }\n      return _completeMultipartUpload;\n    }()\n    /**\r\n     * Uploads a single file to TagoIO.\r\n     * The upload is multipart, meaning that the file will be divided and sent in chunks, resulting in multiple requests being made.\r\n     *\r\n     * @param file the file to be uploaded\r\n     * @param filename the path + filename for the file\r\n     * @param options the upload options for this file\r\n     */\n  }, {\n    key: \"uploadFile\",\n    value: function () {\n      var _uploadFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(file, filename, options) {\n        var _this = this;\n        var MB, cancelled, uploadID, bytesPerChunk, fileSize, chunkAmount, partsPerTime, offsetStart, offsetEnd, partNumber, error, parts, promises, _loop, i;\n        return _regeneratorRuntime().wrap(function _callee15$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                MB = Math.pow(2, 20);\n                cancelled = false;\n                if (options !== null && options !== void 0 && options.onCancelToken) {\n                  options.onCancelToken(function () {\n                    cancelled = true;\n                  });\n                }\n                this.isCanceled(cancelled);\n                _context16.next = 6;\n                return this.createMultipartUpload(filename, options);\n              case 6:\n                uploadID = _context16.sent;\n                bytesPerChunk = (options === null || options === void 0 ? void 0 : options.chunkSize) || 7 * MB;\n                fileSize = file instanceof Buffer ? file.length : file.size;\n                chunkAmount = Math.floor(fileSize / bytesPerChunk) + 1;\n                partsPerTime = 3;\n                if (!(chunkAmount > 1 && bytesPerChunk < 5 * MB)) {\n                  _context16.next = 13;\n                  break;\n                }\n                throw new Error(\"Chunk sizes cannot be lower than 5mb if the upload will have multiple parts\");\n              case 13:\n                offsetStart = 0;\n                offsetEnd = bytesPerChunk;\n                partNumber = 1;\n                error = null;\n                parts = [];\n                promises = [];\n                this.isCanceled(cancelled);\n                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                  var sliced, promise;\n                  return _regeneratorRuntime().wrap(function _loop$(_context15) {\n                    while (1) {\n                      switch (_context15.prev = _context15.next) {\n                        case 0:\n                          sliced = file.slice(offsetStart, offsetEnd);\n                        case 1:\n                          if (!(promises.length >= partsPerTime)) {\n                            _context15.next = 9;\n                            break;\n                          }\n                          _this.isCanceled(cancelled);\n                          if (!error) {\n                            _context15.next = 5;\n                            break;\n                          }\n                          throw error;\n                        case 5:\n                          _context15.next = 7;\n                          return (0, sleep_1.default)(1000);\n                        case 7:\n                          _context15.next = 1;\n                          break;\n                        case 9:\n                          promise = _this._addToQueue(filename, uploadID, partNumber, sliced, options);\n                          promises.push(promise);\n                          promise.then(function (partData) {\n                            if (promises.indexOf(promise) >= 0) {\n                              promises.splice(promises.indexOf(promise), 1);\n                            }\n                            parts.push(partData);\n                            if (options !== null && options !== void 0 && options.onProgress) {\n                              var percentage = parts.length * 100 / chunkAmount;\n                              var limitedPercentage = Math.min(percentage, 100).toFixed(2);\n                              var roundedPercentage = Number(limitedPercentage);\n                              options.onProgress(roundedPercentage);\n                            }\n                          });\n                          promise.catch(function (err) {\n                            error = err;\n                          });\n                          _this.isCanceled(cancelled);\n                          _context15.next = 16;\n                          return (0, sleep_1.default)(500);\n                        case 16:\n                          offsetStart = offsetEnd;\n                          offsetEnd = offsetStart + bytesPerChunk;\n                          partNumber += 1;\n                        case 19:\n                        case \"end\":\n                          return _context15.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n              case 21:\n                if (!(offsetStart < fileSize)) {\n                  _context16.next = 25;\n                  break;\n                }\n                return _context16.delegateYield(_loop(), \"t0\", 23);\n              case 23:\n                _context16.next = 21;\n                break;\n              case 25:\n                if (!(promises.length > 0)) {\n                  _context16.next = 33;\n                  break;\n                }\n                this.isCanceled(cancelled);\n                if (!error) {\n                  _context16.next = 29;\n                  break;\n                }\n                throw error;\n              case 29:\n                _context16.next = 31;\n                return (0, sleep_1.default)(1000);\n              case 31:\n                _context16.next = 25;\n                break;\n              case 33:\n                this.isCanceled(cancelled);\n                i = 0;\n              case 35:\n                if (!(i < 3)) {\n                  _context16.next = 53;\n                  break;\n                }\n                _context16.prev = 36;\n                _context16.next = 39;\n                return this._completeMultipartUpload(filename, uploadID, parts, options);\n              case 39:\n                return _context16.abrupt(\"return\", _context16.sent);\n              case 42:\n                _context16.prev = 42;\n                _context16.t1 = _context16[\"catch\"](36);\n                if (!isLimitError(_context16.t1)) {\n                  _context16.next = 46;\n                  break;\n                }\n                throw _context16.t1.message;\n              case 46:\n                _context16.next = 48;\n                return (0, sleep_1.default)(1000);\n              case 48:\n                if (!(i === 2)) {\n                  _context16.next = 50;\n                  break;\n                }\n                throw _context16.t1;\n              case 50:\n                i += 1;\n                _context16.next = 35;\n                break;\n              case 53:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee15, this, [[36, 42]]);\n      }));\n      function uploadFile(_x27, _x28, _x29) {\n        return _uploadFile.apply(this, arguments);\n      }\n      return uploadFile;\n    }()\n    /**\r\n     * Throw a error if is cancelled\r\n     * @param cancelled\r\n     */\n  }, {\n    key: \"isCanceled\",\n    value: function isCanceled(cancelled) {\n      if (cancelled) {\n        throw new Error(\"Cancelled request\");\n      }\n    }\n  }]);\n  return Files;\n}(TagoIOModule_1.default);\n/**\r\n * Check if the error returned from the API is a usage limit exceeded error.\r\n *\r\n * @param error Error to check.\r\n */\nfunction isLimitError(error) {\n  if (typeof (error === null || error === void 0 ? void 0 : error.message) !== \"string\") {\n    return false;\n  }\n  var message = error === null || error === void 0 ? void 0 : error.message;\n  // TODO: Use status code instead of string error message when available.\n  return message.startsWith(\"You have exceeded the maximum limit\");\n}\nexports.default = Files;","map":{"version":3,"mappings":"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","names":["Files","queryObj","doRequest","path","method","params","pagination_token","paginationToken","qty","quantity","result","files","map","data","fileList","body","file","filesVisibility","url","tagoURL","indexOf","Promise","reject","slice","length","getPathFromUrl","noRedirect","md5","filename","options","dashboard","widget","fieldId","isPublic","contentType","multipart_action","public","field_id","uploadID","partNumber","blob","form","form_data_1","append","String","headers","getHeaders","maxContentLength","Infinity","ETag","PartNumber","maxTries","maxTriesForEachChunk","timeout","timeoutForEachFailedChunk","tries","_uploadPart","isLimitError","message","Error","parts","partsOrdered","sort","a","b","upload_id","MB","Math","pow","cancelled","onCancelToken","isCanceled","createMultipartUpload","bytesPerChunk","chunkSize","fileSize","Buffer","size","chunkAmount","floor","partsPerTime","offsetStart","offsetEnd","error","promises","sliced","promise","_addToQueue","push","then","partData","splice","onProgress","percentage","limitedPercentage","min","toFixed","roundedPercentage","Number","catch","err","i","_completeMultipartUpload","TagoIOModule_1","startsWith","exports"],"sources":["C:\\Users\\kaique\\Documents\\SGA\\widget\\project\\node_modules\\@tago-io\\sdk\\src\\modules\\Account\\Files.ts"],"sourcesContent":["import FormData from \"form-data\";\r\nimport { GenericID } from \"../../common/common.types\";\r\nimport sleep from \"../../common/sleep\";\r\nimport TagoIOModule, { GenericModuleParams } from \"../../common/TagoIOModule\";\r\nimport dateParser from \"../Utils/dateParser\";\r\nimport {\r\n  Base64File,\r\n  CopyFiles,\r\n  FileListInfo,\r\n  FileQuery,\r\n  FilesPermission,\r\n  MoveFiles,\r\n  UploadOptions,\r\n} from \"./files.types\";\r\n\r\nclass Files extends TagoIOModule<GenericModuleParams> {\r\n  /**\r\n   * list of files in account\r\n   * @param queryObj Object with path, pagination and quantity\r\n   */\r\n  public async list(queryObj?: FileQuery): Promise<FileListInfo> {\r\n    const result = await this.doRequest<FileListInfo>({\r\n      path: \"/files\",\r\n      method: \"GET\",\r\n      params: {\r\n        path: queryObj?.path || \"/\",\r\n        pagination_token: queryObj?.paginationToken,\r\n        qty: queryObj?.quantity || 300,\r\n      },\r\n    });\r\n\r\n    result.files = result?.files.map((data) => dateParser(data, [\"last_modified\"]));\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Upload an array of files(Base64) to TagoIO\r\n   * The filename parameter is also full path\r\n   * @param fileList Array of files data to be uploaded\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     filename: \"/myfiles/myfile.ext\",\r\n   *     file: \"StringWithBase64\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\r\n  public async uploadBase64(fileList: Base64File[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files\",\r\n      method: \"POST\",\r\n      body: fileList,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Move/Rename Files\r\n   * @param fileList Array move actions to be made\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     from: \"/myfiles/myOldName.ext\",\r\n   *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\r\n  public async move(fileList: MoveFiles[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files\",\r\n      method: \"PUT\",\r\n      body: fileList,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Copy Files\r\n   * @param fileList Array of copy actions to be made\r\n   * @example\r\n   * ```json\r\n   * fileList: [\r\n   *   {\r\n   *     from: \"/myfiles/myOldName.ext\",\r\n   *     to: \"/myfiles/newFolder/andNewName.ext\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   */\r\n  public async copy(fileList: CopyFiles[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files/copy\",\r\n      method: \"PUT\",\r\n      body: fileList,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Delete Folder or Files\r\n   * @param files An array of files or folders to be deleted\r\n   */\r\n  public async delete(files: string[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files\",\r\n      method: \"DELETE\",\r\n      body: files,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if file is private or public\r\n   * @param file Path of file\r\n   */\r\n  public async checkPermission(file: string): Promise<{ public: boolean }> {\r\n    const result = await this.doRequest<{ public: boolean }>({\r\n      path: \"/files/permission\",\r\n      method: \"GET\",\r\n      params: {\r\n        file,\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Change visibility from files\r\n   * @param filesVisibility An Array with files and their visibility to be setted\r\n   */\r\n  public async changePermission(filesVisibility: FilesPermission[]): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: \"/files/permission\",\r\n      method: \"PUT\",\r\n      body: filesVisibility,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  private async getPathFromUrl(url: string): Promise<string> {\r\n    const tagoURL = url.indexOf(\".tago.io/file/\");\r\n\r\n    if (tagoURL === -1) {\r\n      return Promise.reject(`${url} is not a TagoIO files url`);\r\n    }\r\n\r\n    return url.slice(tagoURL + 8, url.length);\r\n  }\r\n\r\n  /**\r\n   * Get a file url with authenticate token valid for 120 seconds\r\n   * @param url Full TagoIO File url\r\n   */\r\n  public async getFileURLSigned(url: string): Promise<string> {\r\n    const path = await this.getPathFromUrl(url);\r\n\r\n    const result = await this.doRequest<string>({\r\n      path,\r\n      method: \"GET\",\r\n      params: {\r\n        noRedirect: true,\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get file md5 with authenticate token for privates files\r\n   * @param url Full TagoIO File url\r\n   */\r\n  public async getFileMD5(url: string): Promise<string> {\r\n    const path = await this.getPathFromUrl(url);\r\n\r\n    const result = await this.doRequest<string>({\r\n      path,\r\n      method: \"GET\",\r\n      params: {\r\n        md5: true,\r\n        noRedirect: true,\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a multipart upload instance\r\n   * @param filename the path + filename for the file\r\n   * @param options the upload options for this file\r\n   */\r\n  private async createMultipartUpload(filename: string, options?: UploadOptions) {\r\n    const { dashboard, widget, fieldId, isPublic, contentType } = options || {};\r\n\r\n    const path = dashboard && widget && fieldId ? `/data/files/${dashboard}/${widget}` : `/files`;\r\n\r\n    const result = await this.doRequest<any>({\r\n      path,\r\n      method: \"POST\",\r\n      body: {\r\n        multipart_action: \"start\",\r\n        filename,\r\n        public: options?.isPublic,\r\n        contentType,\r\n        ...(fieldId && { field_id: fieldId }),\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Uploads a single part to TagoIO\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param partNumber the sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n   * @param blob the portion of the file to be uploaded\r\n   * @param options the upload options for this file\r\n   */\r\n  async _uploadPart(\r\n    filename: string,\r\n    uploadID: string,\r\n    partNumber: number,\r\n    blob: Buffer | Blob,\r\n    options?: UploadOptions\r\n  ) {\r\n    const { fieldId } = options || {};\r\n    const path =\r\n      options?.dashboard && options?.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;\r\n\r\n    const form = new FormData();\r\n    form.append(\"filename\", filename);\r\n    form.append(\"upload_id\", uploadID);\r\n    form.append(\"part\", String(partNumber));\r\n    form.append(\"file\", blob, filename);\r\n    form.append(\"multipart_action\", \"upload\");\r\n\r\n    if (fieldId) {\r\n      form.append(\"field_id\", fieldId);\r\n    }\r\n\r\n    let headers: any = { \"Content-Type\": \"multipart/form-data\" };\r\n    if (form.getHeaders) {\r\n      headers = form.getHeaders();\r\n    }\r\n\r\n    const result = await this.doRequest<{ ETag: string }>({\r\n      path,\r\n      method: \"POST\",\r\n      body: form,\r\n      maxContentLength: Infinity,\r\n      headers,\r\n    });\r\n\r\n    return {\r\n      ETag: result.ETag,\r\n      PartNumber: partNumber,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds an upload to the queue.\r\n   * It will try to upload for 'opts.maxTriesForEachChunk' and fail\r\n   * if it couldn't upload after those many tries.\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param partNumberthe sequential part number for the upload. This should be 1 in the first call, then 2 in the second call, so on and so forth\r\n   * @param blob the portion of the file to be uploaded\r\n   * @param options see the uploadFile function\r\n   */\r\n  async _addToQueue(\r\n    filename: string,\r\n    uploadID: GenericID,\r\n    partNumber: number,\r\n    blob: Buffer | Blob,\r\n    options?: UploadOptions\r\n  ) {\r\n    const maxTries = options?.maxTriesForEachChunk || 5;\r\n    const timeout = options?.timeoutForEachFailedChunk || 2000;\r\n\r\n    let tries = 0;\r\n\r\n    while (tries < maxTries) {\r\n      try {\r\n        const result = await this._uploadPart(filename, uploadID, partNumber, blob, options);\r\n        return result;\r\n      } catch (ex) {\r\n        if (isLimitError(ex)) {\r\n          throw ex.message;\r\n        }\r\n\r\n        await sleep(timeout);\r\n\r\n        tries += 1;\r\n        if (tries >= maxTries) {\r\n          throw new Error(`Could not upload part number ${partNumber}: ${ex.message}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finishes a multipart upload instance\r\n   * @param filename the path + filename for the file\r\n   * @param uploadID the upload ID acquired by the 'createMultipartUpload' function call\r\n   * @param parts all the parts uploaded to the file\r\n   * @param options the upload options for this file\r\n   */\r\n  async _completeMultipartUpload(\r\n    filename: string,\r\n    uploadID: string,\r\n    parts: { ETag: String; PartNumber: number }[],\r\n    options?: UploadOptions\r\n  ) {\r\n    const { fieldId } = options || {};\r\n    const path =\r\n      options?.dashboard && options?.widget ? `/data/files/${options.dashboard}/${options.widget}` : `/files`;\r\n\r\n    const partsOrdered = parts.sort((a, b) => a.PartNumber - b.PartNumber);\r\n\r\n    const headers = { \"Content-Type\": \"multipart/form-data\" };\r\n\r\n    const result = await this.doRequest<{ file: string }>({\r\n      path,\r\n      method: \"POST\",\r\n      body: {\r\n        multipart_action: \"end\",\r\n        upload_id: uploadID,\r\n        filename,\r\n        parts: partsOrdered,\r\n        ...(fieldId && { field_id: fieldId }),\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Uploads a single file to TagoIO.\r\n   * The upload is multipart, meaning that the file will be divided and sent in chunks, resulting in multiple requests being made.\r\n   *\r\n   * @param file the file to be uploaded\r\n   * @param filename the path + filename for the file\r\n   * @param options the upload options for this file\r\n   */\r\n  public async uploadFile(file: Buffer | Blob, filename: string, options?: UploadOptions) {\r\n    const MB = Math.pow(2, 20);\r\n\r\n    let cancelled = false;\r\n    if (options?.onCancelToken) {\r\n      options.onCancelToken(() => {\r\n        cancelled = true;\r\n      });\r\n    }\r\n\r\n    this.isCanceled(cancelled);\r\n\r\n    const uploadID = await this.createMultipartUpload(filename, options);\r\n\r\n    const bytesPerChunk = options?.chunkSize || 7 * MB;\r\n    const fileSize = file instanceof Buffer ? file.length : file.size;\r\n    const chunkAmount = Math.floor(fileSize / bytesPerChunk) + 1;\r\n    const partsPerTime = 3;\r\n\r\n    if (chunkAmount > 1 && bytesPerChunk < 5 * MB) {\r\n      throw new Error(\"Chunk sizes cannot be lower than 5mb if the upload will have multiple parts\");\r\n    }\r\n\r\n    let offsetStart = 0;\r\n    let offsetEnd = bytesPerChunk;\r\n    let partNumber = 1;\r\n    let error = null;\r\n    const parts: any[] = [];\r\n    const promises: any[] = [];\r\n\r\n    this.isCanceled(cancelled);\r\n\r\n    while (offsetStart < fileSize) {\r\n      const sliced = file.slice(offsetStart, offsetEnd);\r\n\r\n      while (promises.length >= partsPerTime) {\r\n        this.isCanceled(cancelled);\r\n\r\n        if (error) {\r\n          throw error;\r\n        }\r\n\r\n        await sleep(1000);\r\n      }\r\n\r\n      const promise = this._addToQueue(filename, uploadID, partNumber, sliced, options);\r\n      promises.push(promise);\r\n\r\n      promise.then((partData: any) => {\r\n        if (promises.indexOf(promise) >= 0) {\r\n          promises.splice(promises.indexOf(promise), 1);\r\n        }\r\n\r\n        parts.push(partData);\r\n\r\n        if (options?.onProgress) {\r\n          const percentage = (parts.length * 100) / chunkAmount;\r\n          const limitedPercentage = Math.min(percentage, 100).toFixed(2);\r\n          const roundedPercentage = Number(limitedPercentage);\r\n          options.onProgress(roundedPercentage);\r\n        }\r\n      });\r\n\r\n      promise.catch((err: Error) => {\r\n        error = err;\r\n      });\r\n\r\n      this.isCanceled(cancelled);\r\n\r\n      await sleep(500);\r\n\r\n      offsetStart = offsetEnd;\r\n      offsetEnd = offsetStart + bytesPerChunk;\r\n      partNumber += 1;\r\n    }\r\n\r\n    while (promises.length > 0) {\r\n      this.isCanceled(cancelled);\r\n\r\n      if (error) {\r\n        throw error;\r\n      }\r\n      await sleep(1000);\r\n    }\r\n\r\n    this.isCanceled(cancelled);\r\n\r\n    for (let i = 0; i < 3; i += 1) {\r\n      try {\r\n        return await this._completeMultipartUpload(filename, uploadID, parts, options);\r\n      } catch (ex) {\r\n        if (isLimitError(ex)) {\r\n          throw ex.message;\r\n        }\r\n\r\n        await sleep(1000);\r\n        if (i === 2) {\r\n          throw ex;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Throw a error if is cancelled\r\n   * @param cancelled\r\n   */\r\n  private isCanceled(cancelled: boolean) {\r\n    if (cancelled) {\r\n      throw new Error(\"Cancelled request\");\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check if the error returned from the API is a usage limit exceeded error.\r\n *\r\n * @param error Error to check.\r\n */\r\nfunction isLimitError(error: any): boolean {\r\n  if (typeof error?.message !== \"string\") {\r\n    return false;\r\n  }\r\n\r\n  const message: string = error?.message;\r\n\r\n  // TODO: Use status code instead of string error message when available.\r\n  return message.startsWith(\"You have exceeded the maximum limit\");\r\n}\r\n\r\nexport default Files;\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}