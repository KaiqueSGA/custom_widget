{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst TagoIOModule_1 = __importDefault(require(\"../../common/TagoIOModule\"));\nclass Billing extends TagoIOModule_1.default {\n  /**\r\n   * Get the account subscription information.\r\n   */\n  async getSubscription() {\n    const result = await this.doRequest({\n      path: `/account/subscription`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Edit an account's subscription to change plan, services or add-ons.\r\n   *\r\n   * Only one of either `plan`, `services`, or `addons` can be in `subscription`.\r\n   *\r\n   * @param subscription Object with updates to subscription.\r\n   *\r\n   * @throws If the subscription has a pending operation.\r\n   * @throws If updating more than one of plan, services and add-ons at the same time.\r\n   * @throws If purchasing add-ons or changing service limits on the Free plan.\r\n   * @throws If using an invalid coupon.\r\n   */\n  async editSubscription(subscription) {\n    const result = await this.doRequest({\n      path: `/account/subscription`,\n      method: \"POST\",\n      body: subscription\n    });\n    return result;\n  }\n  /**\r\n   * Get information for the account subscription schedule for downgrades.\r\n   *\r\n   * In the response, `subscription` reflects how the entire subscription will look\r\n   * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade\r\n   * for either plan, services or add-ons, everything is returned and not only the changes.\r\n   */\n  async getSubscriptionSchedule() {\n    const result = await this.doRequest({\n      path: `/account/subscription/schedule`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Get pricing for plans, services and add-ons.\r\n   */\n  async getPrices() {\n    const result = await this.doRequest({\n      path: `/pricing`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Get pricing for plans, services and add-ons with proration when applicable.\r\n   */\n  async getProratedPrices() {\n    const result = await this.doRequest({\n      path: `/pricing/prorated`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Get information about the account's payment method credit card, credit balance,\r\n   * and the applied coupon.\r\n   */\n  async getPaymentMethod() {\n    const result = await this.doRequest({\n      path: `/account/payment_method`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Edit an account's payment method.\r\n   *\r\n   * @param stripeCardToken Token for the new payment method added via Stripe API.\r\n   *\r\n   * @throws If token is invalid or Stripe can't create the payment method with it.\r\n   *\r\n   * @returns Success or error message.\r\n   */\n  async editPaymentMethod(stripeCardToken) {\n    const result = await this.doRequest({\n      path: `/account/payment_method`,\n      method: \"POST\",\n      body: {\n        token: stripeCardToken\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Remove an account's payment method from the Stripe subscription.\r\n   *\r\n   * Only removes the card if the account is on the Free plan or if it has enough credit balance.\r\n   *\r\n   * @throws If subscription is active with an upcoming invoice.\r\n   * @throws If account doesn't have a payment method.\r\n   *\r\n   * @returns Success or error message.\r\n   */\n  async removePaymentMethod() {\n    const result = await this.doRequest({\n      path: `/account/payment_method`,\n      method: \"DELETE\"\n    });\n    return result;\n  }\n  /**\r\n   * Get an account's billing information.\r\n   */\n  async getBillingInformation() {\n    const result = await this.doRequest({\n      path: `/account/billing`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Edit an account's billing information.\r\n   *\r\n   * @param billingInformation Data to be updated in the account's billing information.\r\n   */\n  async editBillingInformation(billingInformation) {\n    const result = await this.doRequest({\n      path: `/account/billing`,\n      method: \"PUT\",\n      body: billingInformation\n    });\n    return result;\n  }\n  /**\r\n   * Get the resource allocation for all profiles in an account.\r\n   */\n  async getAllocation() {\n    const result = await this.doRequest({\n      path: `/account/allocation`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Edit the resource allocation for the profiles in an account.\r\n   *\r\n   * The resource allocation array doesn't need to have an object for each of the account's profiles,\r\n   * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.\r\n   *\r\n   * The resource allocation object for a profile doesn't need to have all the services.\r\n   *\r\n   * @param allocation Array with the resource allocation\r\n   *\r\n   * @throws If passed an object that is not an allocation array.\r\n   * @throws If the account only has one profile.\r\n   * @throws If one of the profile IDs in the allocation array doesn't exist in the account.\r\n   * @throws If the allocated amount for one of the services exceeds the available amount.\r\n   *\r\n   * @returns Success message.\r\n   */\n  async editAllocation(allocation) {\n    const result = await this.doRequest({\n      path: `/account/allocation`,\n      method: \"POST\",\n      body: allocation\n    });\n    return result;\n  }\n  /**\r\n   * Get the payment history for an account.\r\n   *\r\n   * The route uses pagination and the `lastId` parameter should be the `stripe_id`\r\n   * parameter from the last history entry.\r\n   *\r\n   * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.\r\n   *\r\n   * @throws If `lastId` is passed and is invalid.\r\n   *\r\n   * @returns Array with payment history entries or an empty array when no entries are available.\r\n   */\n  async getPaymentHistory(queryObj) {\n    const result = await this.doRequest({\n      path: `/account/payment_history`,\n      method: \"GET\",\n      params: {\n        amount: queryObj?.amount ?? 10,\n        ...(queryObj?.lastId && {\n          last_id: queryObj?.lastId\n        })\n      }\n    });\n    return result;\n  }\n  /**\r\n   * Get a summary for important information in an account's subscription.\r\n   *\r\n   * The values returned by this route are cached.\r\n   *\r\n   * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.\r\n   */\n  async getSubscriptionSummary() {\n    const result = await this.doRequest({\n      path: `/account/subscription/summary`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Check if a coupon is valid by its promo code.\r\n   *\r\n   * @param code Customer-facing code for the coupon (promo code).\r\n   *\r\n   * @throws If the coupon code is not valid or not found.\r\n   * @throws If coupon is specific to a an account.\r\n   * @throws If coupon can only be applied to new subscriptions.\r\n   */\n  async checkDiscountCoupon(code) {\n    const result = await this.doRequest({\n      path: `/account/subscription/coupon/${code}`,\n      method: \"GET\"\n    });\n    return result;\n  }\n  /**\r\n   * Cancel a scheduled downgrade.\r\n   *\r\n   * @throws If the subscription has no schedule.\r\n   *\r\n   * @returns Success message.\r\n   */\n  async cancelDowngrade() {\n    const result = await this.doRequest({\n      path: `/account/subscription/schedule`,\n      method: \"DELETE\"\n    });\n    return result;\n  }\n  /**\r\n   * Retry payment for an operation where the payment was unsuccessful.\r\n   *\r\n   * Works for payment errors in recurring payments or in subscription upgrade operations.\r\n   *\r\n   * @throws If account has no subscription.\r\n   * @throws If there's no pending payment.\r\n   * @throws If payment method is declined or for other payment processing errors.\r\n   *\r\n   * @returns Success message.\r\n   */\n  async retryLastPayment() {\n    const result = await this.doRequest({\n      path: `/account/subscription/pending/retry`,\n      method: \"POST\"\n    });\n    return result;\n  }\n  /**\r\n   * Cancel the last pending operation if the payment has failed.\r\n   *\r\n   * Works for subscription upgrade operations and not for recurring payment errors.\r\n   *\r\n   * @throws If there's no pending payment.\r\n   *\r\n   * @returns Success message.\r\n   */\n  async cancelLastOperation() {\n    const result = await this.doRequest({\n      path: `/account/subscription/pending/cancel`,\n      method: \"POST\"\n    });\n    return result;\n  }\n}\nexports.default = Billing;","map":{"version":3,"mappings":"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","names":["Billing","TagoIOModule_1","getSubscription","result","doRequest","path","method","editSubscription","subscription","body","getSubscriptionSchedule","getPrices","getProratedPrices","getPaymentMethod","editPaymentMethod","stripeCardToken","token","removePaymentMethod","getBillingInformation","editBillingInformation","billingInformation","getAllocation","editAllocation","allocation","getPaymentHistory","queryObj","params","amount","lastId","last_id","getSubscriptionSummary","checkDiscountCoupon","code","cancelDowngrade","retryLastPayment","cancelLastOperation","exports"],"sources":["C:\\Users\\kaique\\Documents\\SGA\\widget\\project\\node_modules\\@tago-io\\sdk\\src\\modules\\Account\\Billing.ts"],"sourcesContent":["import { GenericID } from \"../../common/common.types\";\r\nimport TagoIOModule, { GenericModuleParams } from \"../../common/TagoIOModule\";\r\nimport type {\r\n  BillingAddOn,\r\n  BillingCoupon,\r\n  BillingEditInformation,\r\n  BillingEditResourceAllocation,\r\n  BillingEditSubscription,\r\n  BillingInformation,\r\n  BillingPaymentHistoryEntry,\r\n  BillingPaymentMethod,\r\n  BillingPrices,\r\n  BillingResourceAllocation,\r\n  BillingSchedule,\r\n  BillingSubscription,\r\n  BillingSubscriptionSummary,\r\n} from \"./billing.types\";\r\n\r\nclass Billing extends TagoIOModule<GenericModuleParams> {\r\n  /**\r\n   * Get the account subscription information.\r\n   */\r\n  public async getSubscription(): Promise<BillingSubscription> {\r\n    const result = await this.doRequest<BillingSubscription>({\r\n      path: `/account/subscription`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit an account's subscription to change plan, services or add-ons.\r\n   *\r\n   * Only one of either `plan`, `services`, or `addons` can be in `subscription`.\r\n   *\r\n   * @param subscription Object with updates to subscription.\r\n   *\r\n   * @throws If the subscription has a pending operation.\r\n   * @throws If updating more than one of plan, services and add-ons at the same time.\r\n   * @throws If purchasing add-ons or changing service limits on the Free plan.\r\n   * @throws If using an invalid coupon.\r\n   */\r\n  public async editSubscription(subscription: BillingEditSubscription): Promise<void> {\r\n    const result = await this.doRequest<void>({\r\n      path: `/account/subscription`,\r\n      method: \"POST\",\r\n      body: subscription,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get information for the account subscription schedule for downgrades.\r\n   *\r\n   * In the response, `subscription` reflects how the entire subscription will look\r\n   * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade\r\n   * for either plan, services or add-ons, everything is returned and not only the changes.\r\n   */\r\n  public async getSubscriptionSchedule(): Promise<BillingSchedule> {\r\n    const result = await this.doRequest<BillingSchedule>({\r\n      path: `/account/subscription/schedule`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get pricing for plans, services and add-ons.\r\n   */\r\n  public async getPrices(): Promise<BillingPrices> {\r\n    const result = await this.doRequest<BillingPrices>({\r\n      path: `/pricing`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get pricing for plans, services and add-ons with proration when applicable.\r\n   */\r\n  public async getProratedPrices(): Promise<BillingPrices> {\r\n    const result = await this.doRequest<BillingPrices>({\r\n      path: `/pricing/prorated`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get information about the account's payment method credit card, credit balance,\r\n   * and the applied coupon.\r\n   */\r\n  public async getPaymentMethod(): Promise<BillingPaymentMethod> {\r\n    const result = await this.doRequest<BillingPaymentMethod>({\r\n      path: `/account/payment_method`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit an account's payment method.\r\n   *\r\n   * @param stripeCardToken Token for the new payment method added via Stripe API.\r\n   *\r\n   * @throws If token is invalid or Stripe can't create the payment method with it.\r\n   *\r\n   * @returns Success or error message.\r\n   */\r\n  public async editPaymentMethod(stripeCardToken: string): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/payment_method`,\r\n      method: \"POST\",\r\n      body: { token: stripeCardToken },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Remove an account's payment method from the Stripe subscription.\r\n   *\r\n   * Only removes the card if the account is on the Free plan or if it has enough credit balance.\r\n   *\r\n   * @throws If subscription is active with an upcoming invoice.\r\n   * @throws If account doesn't have a payment method.\r\n   *\r\n   * @returns Success or error message.\r\n   */\r\n  public async removePaymentMethod(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/payment_method`,\r\n      method: \"DELETE\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get an account's billing information.\r\n   */\r\n  public async getBillingInformation(): Promise<BillingInformation> {\r\n    const result = await this.doRequest<BillingInformation>({\r\n      path: `/account/billing`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit an account's billing information.\r\n   *\r\n   * @param billingInformation Data to be updated in the account's billing information.\r\n   */\r\n  public async editBillingInformation(billingInformation: BillingEditInformation): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/billing`,\r\n      method: \"PUT\",\r\n      body: billingInformation,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get the resource allocation for all profiles in an account.\r\n   */\r\n  public async getAllocation(): Promise<BillingResourceAllocation> {\r\n    const result = await this.doRequest<BillingResourceAllocation>({\r\n      path: `/account/allocation`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Edit the resource allocation for the profiles in an account.\r\n   *\r\n   * The resource allocation array doesn't need to have an object for each of the account's profiles,\r\n   * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.\r\n   *\r\n   * The resource allocation object for a profile doesn't need to have all the services.\r\n   *\r\n   * @param allocation Array with the resource allocation\r\n   *\r\n   * @throws If passed an object that is not an allocation array.\r\n   * @throws If the account only has one profile.\r\n   * @throws If one of the profile IDs in the allocation array doesn't exist in the account.\r\n   * @throws If the allocated amount for one of the services exceeds the available amount.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async editAllocation(allocation: BillingEditResourceAllocation): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/allocation`,\r\n      method: \"POST\",\r\n      body: allocation,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get the payment history for an account.\r\n   *\r\n   * The route uses pagination and the `lastId` parameter should be the `stripe_id`\r\n   * parameter from the last history entry.\r\n   *\r\n   * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.\r\n   *\r\n   * @throws If `lastId` is passed and is invalid.\r\n   *\r\n   * @returns Array with payment history entries or an empty array when no entries are available.\r\n   */\r\n  public async getPaymentHistory(queryObj?: {\r\n    amount?: number;\r\n    lastId?: string;\r\n  }): Promise<BillingPaymentHistoryEntry[]> {\r\n    const result = await this.doRequest<BillingPaymentHistoryEntry[]>({\r\n      path: `/account/payment_history`,\r\n      method: \"GET\",\r\n      params: {\r\n        amount: queryObj?.amount ?? 10,\r\n        ...(queryObj?.lastId && { last_id: queryObj?.lastId }),\r\n      },\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get a summary for important information in an account's subscription.\r\n   *\r\n   * The values returned by this route are cached.\r\n   *\r\n   * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.\r\n   */\r\n  public async getSubscriptionSummary(): Promise<BillingSubscriptionSummary | undefined> {\r\n    const result = await this.doRequest<BillingSubscriptionSummary | undefined>({\r\n      path: `/account/subscription/summary`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if a coupon is valid by its promo code.\r\n   *\r\n   * @param code Customer-facing code for the coupon (promo code).\r\n   *\r\n   * @throws If the coupon code is not valid or not found.\r\n   * @throws If coupon is specific to a an account.\r\n   * @throws If coupon can only be applied to new subscriptions.\r\n   */\r\n  public async checkDiscountCoupon(code?: string): Promise<BillingCoupon> {\r\n    const result = await this.doRequest<BillingCoupon>({\r\n      path: `/account/subscription/coupon/${code}`,\r\n      method: \"GET\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Cancel a scheduled downgrade.\r\n   *\r\n   * @throws If the subscription has no schedule.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async cancelDowngrade(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/subscription/schedule`,\r\n      method: \"DELETE\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Retry payment for an operation where the payment was unsuccessful.\r\n   *\r\n   * Works for payment errors in recurring payments or in subscription upgrade operations.\r\n   *\r\n   * @throws If account has no subscription.\r\n   * @throws If there's no pending payment.\r\n   * @throws If payment method is declined or for other payment processing errors.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async retryLastPayment(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/subscription/pending/retry`,\r\n      method: \"POST\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Cancel the last pending operation if the payment has failed.\r\n   *\r\n   * Works for subscription upgrade operations and not for recurring payment errors.\r\n   *\r\n   * @throws If there's no pending payment.\r\n   *\r\n   * @returns Success message.\r\n   */\r\n  public async cancelLastOperation(): Promise<string> {\r\n    const result = await this.doRequest<string>({\r\n      path: `/account/subscription/pending/cancel`,\r\n      method: \"POST\",\r\n    });\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Billing;\r\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}