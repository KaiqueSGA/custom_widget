"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const TagoIOModule_1 = __importDefault(require("../../common/TagoIOModule"));
class Billing extends TagoIOModule_1.default {
    /**
     * Get the account subscription information.
     */
    async getSubscription() {
        const result = await this.doRequest({
            path: `/account/subscription`,
            method: "GET",
        });
        return result;
    }
    /**
     * Edit an account's subscription to change plan, services or add-ons.
     *
     * Only one of either `plan`, `services`, or `addons` can be in `subscription`.
     *
     * @param subscription Object with updates to subscription.
     *
     * @throws If the subscription has a pending operation.
     * @throws If updating more than one of plan, services and add-ons at the same time.
     * @throws If purchasing add-ons or changing service limits on the Free plan.
     * @throws If using an invalid coupon.
     */
    async editSubscription(subscription) {
        const result = await this.doRequest({
            path: `/account/subscription`,
            method: "POST",
            body: subscription,
        });
        return result;
    }
    /**
     * Get information for the account subscription schedule for downgrades.
     *
     * In the response, `subscription` reflects how the entire subscription will look
     * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade
     * for either plan, services or add-ons, everything is returned and not only the changes.
     */
    async getSubscriptionSchedule() {
        const result = await this.doRequest({
            path: `/account/subscription/schedule`,
            method: "GET",
        });
        return result;
    }
    /**
     * Get pricing for plans, services and add-ons.
     */
    async getPrices() {
        const result = await this.doRequest({
            path: `/pricing`,
            method: "GET",
        });
        return result;
    }
    /**
     * Get pricing for plans, services and add-ons with proration when applicable.
     */
    async getProratedPrices() {
        const result = await this.doRequest({
            path: `/pricing/prorated`,
            method: "GET",
        });
        return result;
    }
    /**
     * Get information about the account's payment method credit card, credit balance,
     * and the applied coupon.
     */
    async getPaymentMethod() {
        const result = await this.doRequest({
            path: `/account/payment_method`,
            method: "GET",
        });
        return result;
    }
    /**
     * Edit an account's payment method.
     *
     * @param stripeCardToken Token for the new payment method added via Stripe API.
     *
     * @throws If token is invalid or Stripe can't create the payment method with it.
     *
     * @returns Success or error message.
     */
    async editPaymentMethod(stripeCardToken) {
        const result = await this.doRequest({
            path: `/account/payment_method`,
            method: "POST",
            body: { token: stripeCardToken },
        });
        return result;
    }
    /**
     * Remove an account's payment method from the Stripe subscription.
     *
     * Only removes the card if the account is on the Free plan or if it has enough credit balance.
     *
     * @throws If subscription is active with an upcoming invoice.
     * @throws If account doesn't have a payment method.
     *
     * @returns Success or error message.
     */
    async removePaymentMethod() {
        const result = await this.doRequest({
            path: `/account/payment_method`,
            method: "DELETE",
        });
        return result;
    }
    /**
     * Get an account's billing information.
     */
    async getBillingInformation() {
        const result = await this.doRequest({
            path: `/account/billing`,
            method: "GET",
        });
        return result;
    }
    /**
     * Edit an account's billing information.
     *
     * @param billingInformation Data to be updated in the account's billing information.
     */
    async editBillingInformation(billingInformation) {
        const result = await this.doRequest({
            path: `/account/billing`,
            method: "PUT",
            body: billingInformation,
        });
        return result;
    }
    /**
     * Get the resource allocation for all profiles in an account.
     */
    async getAllocation() {
        const result = await this.doRequest({
            path: `/account/allocation`,
            method: "GET",
        });
        return result;
    }
    /**
     * Edit the resource allocation for the profiles in an account.
     *
     * The resource allocation array doesn't need to have an object for each of the account's profiles,
     * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.
     *
     * The resource allocation object for a profile doesn't need to have all the services.
     *
     * @param allocation Array with the resource allocation
     *
     * @throws If passed an object that is not an allocation array.
     * @throws If the account only has one profile.
     * @throws If one of the profile IDs in the allocation array doesn't exist in the account.
     * @throws If the allocated amount for one of the services exceeds the available amount.
     *
     * @returns Success message.
     */
    async editAllocation(allocation) {
        const result = await this.doRequest({
            path: `/account/allocation`,
            method: "POST",
            body: allocation,
        });
        return result;
    }
    /**
     * Get the payment history for an account.
     *
     * The route uses pagination and the `lastId` parameter should be the `stripe_id`
     * parameter from the last history entry.
     *
     * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.
     *
     * @throws If `lastId` is passed and is invalid.
     *
     * @returns Array with payment history entries or an empty array when no entries are available.
     */
    async getPaymentHistory(queryObj) {
        const result = await this.doRequest({
            path: `/account/payment_history`,
            method: "GET",
            params: {
                amount: queryObj?.amount ?? 10,
                ...(queryObj?.lastId && { last_id: queryObj?.lastId }),
            },
        });
        return result;
    }
    /**
     * Get a summary for important information in an account's subscription.
     *
     * The values returned by this route are cached.
     *
     * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.
     */
    async getSubscriptionSummary() {
        const result = await this.doRequest({
            path: `/account/subscription/summary`,
            method: "GET",
        });
        return result;
    }
    /**
     * Check if a coupon is valid by its promo code.
     *
     * @param code Customer-facing code for the coupon (promo code).
     *
     * @throws If the coupon code is not valid or not found.
     * @throws If coupon is specific to a an account.
     * @throws If coupon can only be applied to new subscriptions.
     */
    async checkDiscountCoupon(code) {
        const result = await this.doRequest({
            path: `/account/subscription/coupon/${code}`,
            method: "GET",
        });
        return result;
    }
    /**
     * Cancel a scheduled downgrade.
     *
     * @throws If the subscription has no schedule.
     *
     * @returns Success message.
     */
    async cancelDowngrade() {
        const result = await this.doRequest({
            path: `/account/subscription/schedule`,
            method: "DELETE",
        });
        return result;
    }
    /**
     * Retry payment for an operation where the payment was unsuccessful.
     *
     * Works for payment errors in recurring payments or in subscription upgrade operations.
     *
     * @throws If account has no subscription.
     * @throws If there's no pending payment.
     * @throws If payment method is declined or for other payment processing errors.
     *
     * @returns Success message.
     */
    async retryLastPayment() {
        const result = await this.doRequest({
            path: `/account/subscription/pending/retry`,
            method: "POST",
        });
        return result;
    }
    /**
     * Cancel the last pending operation if the payment has failed.
     *
     * Works for subscription upgrade operations and not for recurring payment errors.
     *
     * @throws If there's no pending payment.
     *
     * @returns Success message.
     */
    async cancelLastOperation() {
        const result = await this.doRequest({
            path: `/account/subscription/pending/cancel`,
            method: "POST",
        });
        return result;
    }
}
exports.default = Billing;
//# sourceMappingURL=Billing.js.map