import TagoIOModule, { GenericModuleParams } from "../../common/TagoIOModule";
import type { BillingCoupon, BillingEditInformation, BillingEditResourceAllocation, BillingEditSubscription, BillingInformation, BillingPaymentHistoryEntry, BillingPaymentMethod, BillingPrices, BillingResourceAllocation, BillingSchedule, BillingSubscription, BillingSubscriptionSummary } from "./billing.types";
declare class Billing extends TagoIOModule<GenericModuleParams> {
    /**
     * Get the account subscription information.
     */
    getSubscription(): Promise<BillingSubscription>;
    /**
     * Edit an account's subscription to change plan, services or add-ons.
     *
     * Only one of either `plan`, `services`, or `addons` can be in `subscription`.
     *
     * @param subscription Object with updates to subscription.
     *
     * @throws If the subscription has a pending operation.
     * @throws If updating more than one of plan, services and add-ons at the same time.
     * @throws If purchasing add-ons or changing service limits on the Free plan.
     * @throws If using an invalid coupon.
     */
    editSubscription(subscription: BillingEditSubscription): Promise<void>;
    /**
     * Get information for the account subscription schedule for downgrades.
     *
     * In the response, `subscription` reflects how the entire subscription will look
     * at the end of the billing cycle when the downgrade is applied. If there is a scheduled downgrade
     * for either plan, services or add-ons, everything is returned and not only the changes.
     */
    getSubscriptionSchedule(): Promise<BillingSchedule>;
    /**
     * Get pricing for plans, services and add-ons.
     */
    getPrices(): Promise<BillingPrices>;
    /**
     * Get pricing for plans, services and add-ons with proration when applicable.
     */
    getProratedPrices(): Promise<BillingPrices>;
    /**
     * Get information about the account's payment method credit card, credit balance,
     * and the applied coupon.
     */
    getPaymentMethod(): Promise<BillingPaymentMethod>;
    /**
     * Edit an account's payment method.
     *
     * @param stripeCardToken Token for the new payment method added via Stripe API.
     *
     * @throws If token is invalid or Stripe can't create the payment method with it.
     *
     * @returns Success or error message.
     */
    editPaymentMethod(stripeCardToken: string): Promise<string>;
    /**
     * Remove an account's payment method from the Stripe subscription.
     *
     * Only removes the card if the account is on the Free plan or if it has enough credit balance.
     *
     * @throws If subscription is active with an upcoming invoice.
     * @throws If account doesn't have a payment method.
     *
     * @returns Success or error message.
     */
    removePaymentMethod(): Promise<string>;
    /**
     * Get an account's billing information.
     */
    getBillingInformation(): Promise<BillingInformation>;
    /**
     * Edit an account's billing information.
     *
     * @param billingInformation Data to be updated in the account's billing information.
     */
    editBillingInformation(billingInformation: BillingEditInformation): Promise<string>;
    /**
     * Get the resource allocation for all profiles in an account.
     */
    getAllocation(): Promise<BillingResourceAllocation>;
    /**
     * Edit the resource allocation for the profiles in an account.
     *
     * The resource allocation array doesn't need to have an object for each of the account's profiles,
     * as long as the sum of the allocated amounts for the services doesn't exceed the account's service limit.
     *
     * The resource allocation object for a profile doesn't need to have all the services.
     *
     * @param allocation Array with the resource allocation
     *
     * @throws If passed an object that is not an allocation array.
     * @throws If the account only has one profile.
     * @throws If one of the profile IDs in the allocation array doesn't exist in the account.
     * @throws If the allocated amount for one of the services exceeds the available amount.
     *
     * @returns Success message.
     */
    editAllocation(allocation: BillingEditResourceAllocation): Promise<string>;
    /**
     * Get the payment history for an account.
     *
     * The route uses pagination and the `lastId` parameter should be the `stripe_id`
     * parameter from the last history entry.
     *
     * @param queryObj Object to configure the amount of entries fetched and the ID of the history entry for pagination.
     *
     * @throws If `lastId` is passed and is invalid.
     *
     * @returns Array with payment history entries or an empty array when no entries are available.
     */
    getPaymentHistory(queryObj?: {
        amount?: number;
        lastId?: string;
    }): Promise<BillingPaymentHistoryEntry[]>;
    /**
     * Get a summary for important information in an account's subscription.
     *
     * The values returned by this route are cached.
     *
     * @returns Summary data for a subscription or `undefined` when the account does not have a subscription.
     */
    getSubscriptionSummary(): Promise<BillingSubscriptionSummary | undefined>;
    /**
     * Check if a coupon is valid by its promo code.
     *
     * @param code Customer-facing code for the coupon (promo code).
     *
     * @throws If the coupon code is not valid or not found.
     * @throws If coupon is specific to a an account.
     * @throws If coupon can only be applied to new subscriptions.
     */
    checkDiscountCoupon(code?: string): Promise<BillingCoupon>;
    /**
     * Cancel a scheduled downgrade.
     *
     * @throws If the subscription has no schedule.
     *
     * @returns Success message.
     */
    cancelDowngrade(): Promise<string>;
    /**
     * Retry payment for an operation where the payment was unsuccessful.
     *
     * Works for payment errors in recurring payments or in subscription upgrade operations.
     *
     * @throws If account has no subscription.
     * @throws If there's no pending payment.
     * @throws If payment method is declined or for other payment processing errors.
     *
     * @returns Success message.
     */
    retryLastPayment(): Promise<string>;
    /**
     * Cancel the last pending operation if the payment has failed.
     *
     * Works for subscription upgrade operations and not for recurring payment errors.
     *
     * @throws If there's no pending payment.
     *
     * @returns Success message.
     */
    cancelLastOperation(): Promise<string>;
}
export default Billing;
//# sourceMappingURL=Billing.d.ts.map