"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const config_1 = __importDefault(require("../config"));
const sleep_1 = __importDefault(require("../common/sleep"));
const isBrowser_1 = __importDefault(require("./isBrowser"));
const envParams_json_1 = __importDefault(require("./envParams.json"));
const RequestInProgress_1 = require("../common/RequestInProgress");
const Cache_1 = require("../common/Cache");
/**
 * Handle the TagoIO Response
 * @internal
 * @param result Axios Result
 */
function resultHandler(result) {
    if (!result.data) {
        throw result.statusText;
    }
    if (result.status === 200 && result.config.url.includes("/data/export")) {
        return { data: result.data };
    }
    if (result.data.status !== true) {
        return result.data.message || result.data.result || result.data;
    }
    return { data: result.data.result };
}
/**
 * Handle all request to TagoIO API
 * @internal
 * @param axiosObj Axios Object
 */
async function apiRequest(axiosObj, cacheTTL) {
    if (cacheTTL) {
        if ((0, RequestInProgress_1.isRequestInProgress)(axiosObj)) {
            await (0, sleep_1.default)(100);
            return apiRequest(axiosObj, cacheTTL);
        }
        const objCached = (0, Cache_1.getCache)(axiosObj);
        if (objCached) {
            return objCached;
        }
    }
    (0, RequestInProgress_1.addRequestInProgress)(axiosObj);
    axiosObj.timeout = config_1.default.requestTimeout;
    if ((0, isBrowser_1.default)()) {
        // Prevent cache on Browsers
        axiosObj.headers = {
            ...axiosObj.headers,
            Pragma: "no-cache",
            "Cache-Control": "no-cache",
        };
    }
    else if (typeof process !== "undefined") {
        const banner = process.env.T_ANALYSIS_CONTEXT === "tago-io"
            ? `(Running at TagoIO)`
            : `(External; Node.js/${process.version} ${process.platform}/${process.arch})`;
        axiosObj.headers = {
            ...axiosObj.headers,
            "User-Agent": `TagoIO-SDK|JS|${envParams_json_1.default.version} ${banner}`,
        };
    }
    const request = () => {
        return (0, axios_1.default)(axiosObj)
            .then(resultHandler)
            .catch((error) => ({ error }));
    };
    let result;
    let resulterror;
    for (let i = 1; i <= config_1.default.requestAttempts; i += 1) {
        const { data, error } = await request();
        if (!error) {
            result = data;
            break;
        }
        if (error.response) {
            resulterror = {
                from: "SERVER_RESPONSE",
                url: error.config.url,
                method: String(error.config.method).toUpperCase(),
                status: error.response.status,
                code: error.code || "UNKNOWN",
                statusText: error.response.statusText,
            };
        }
        else {
            resulterror = {
                from: "CLIENT_REQUEST",
                url: error.config.url,
                method: String(error.config.method).toUpperCase(),
                status: -1,
                code: error.code || "UNKNOWN",
                statusText: "UNKNOWN",
            };
        }
        // ? Requests with client errors not retry.
        if (error.response && (error.response.status >= 400 || error.response.status < 500)) {
            resulterror = resultHandler(error.response);
            break;
        }
        await (0, sleep_1.default)(1500);
    }
    if (cacheTTL && result && !resulterror) {
        (0, Cache_1.addCache)(axiosObj, result, cacheTTL);
    }
    (0, RequestInProgress_1.removeRequestInProgress)(axiosObj);
    if (!result && resulterror) {
        throw resulterror;
    }
    return result;
}
exports.default = apiRequest;
//# sourceMappingURL=apiRequest.js.map